<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zitterbewegung Cube - GA Vanilla Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a1a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #e0e0ff;
            padding: 20px;
        }
        h1 {
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(90deg, #ff6b9d, #c44dff, #6b9dff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { font-size: 0.95rem; color: #8888aa; margin-bottom: 1rem; }
        canvas {
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(100, 100, 255, 0.2);
            background: #0a0a12;
        }
        .controls {
            margin-top: 1.2rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255,255,255,0.05);
            padding: 0.6rem 1rem;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .control-group label { font-size: 0.75rem; color: #aac; margin-bottom: 0.3rem; }
        input[type="range"] { width: 100px; accent-color: #c44dff; }
        .info {
            margin-top: 1.2rem;
            padding: 0.8rem 1.2rem;
            background: rgba(100,100,200,0.1);
            border-radius: 10px;
            border: 1px solid rgba(100,100,200,0.2);
            max-width: 700px;
            font-size: 0.85rem;
            color: #99b;
            text-align: center;
        }
        .formula { font-family: 'Times New Roman', serif; font-style: italic; color: #b9f; }
        #debug { font-family: monospace; font-size: 0.7rem; color: #666; margin-top: 0.5rem; }
    </style>
</head>
<body>
    <h1>Zitterbewegung Cube</h1>
    <p class="subtitle">Using Vanilla Geometric Algebra (PGA3D)</p>
    
    <canvas id="canvas" width="700" height="500"></canvas>
    
    <div class="controls">
        <div class="control-group">
            <label>Helix Radius</label>
            <input type="range" id="radius" min="0.5" max="2.5" step="0.1" value="1.2">
        </div>
        <div class="control-group">
            <label>Helix Pitch</label>
            <input type="range" id="pitch" min="0.1" max="1.5" step="0.1" value="0.4">
        </div>
        <div class="control-group">
            <label>Spin Speed</label>
            <input type="range" id="spin" min="0.5" max="4" step="0.5" value="2">
        </div>
        <div class="control-group">
            <label>Helix Speed</label>
            <input type="range" id="helix" min="0.2" max="2" step="0.1" value="0.7">
        </div>
    </div>
    
    <div class="info">
        Rotation via <span class="formula">PGA3D rotors</span>: 
        <span class="formula">R = cos(θ/2) + sin(θ/2)·B</span> where B is a bivector plane.
        Compound rotation: <span class="formula">R = R<sub>z</sub> · R<sub>y</sub> · R<sub>x</sub></span>.
        Transform: <span class="formula">P′ = R · P · R̃</span>
    </div>
    <div id="debug"></div>

    <!-- Inline the GA library for portability -->
    <script>
    // ============================================================================
    // MINIMAL PGA3D IMPLEMENTATION (extracted from ga_vanilla.js)
    // ============================================================================
    
    const PGA3D = (function() {
        const EPSILON = 1e-10;
        const { sqrt, sin, cos } = Math;

        // Simple Rotor class for PGA3D rotations
        class Rotor {
            constructor(s = 1, e12 = 0, e31 = 0, e23 = 0) {
                this.s = s;
                this.e12 = e12;  // XY plane
                this.e31 = e31;  // ZX plane
                this.e23 = e23;  // YZ plane
            }

            static fromAxisAngle(ax, ay, az, angle) {
                const norm = sqrt(ax*ax + ay*ay + az*az);
                if (norm < EPSILON) return new Rotor(1, 0, 0, 0);
                const half = angle / 2;
                const sinH = sin(half) / norm;
                // axis (ax,ay,az) → bivector: ax*e23 + ay*e31 + az*e12
                return new Rotor(cos(half), az * sinH, ay * sinH, ax * sinH);
            }

            mul(r) {
                return new Rotor(
                    this.s*r.s   - this.e12*r.e12 - this.e31*r.e31 - this.e23*r.e23,
                    this.s*r.e12 + this.e12*r.s   + this.e31*r.e23 - this.e23*r.e31,
                    this.s*r.e31 + this.e31*r.s   - this.e12*r.e23 + this.e23*r.e12,
                    this.s*r.e23 + this.e23*r.s   + this.e12*r.e31 - this.e31*r.e12
                );
            }

            // Sandwich product R*v*R̃ using cross-product formula
            apply(x, y, z) {
                const w = this.s;
                const i = this.e23, j = -this.e31, k = this.e12;
                // v' = v + 2w(q×v) + 2(q×(q×v))
                const cx = j*z - k*y, cy = k*x - i*z, cz = i*y - j*x;
                const ccx = j*cz - k*cy, ccy = k*cx - i*cz, ccz = i*cy - j*cx;
                return [x + 2*(w*cx + ccx), y + 2*(w*cy + ccy), z + 2*(w*cz + ccz)];
            }

            toString() {
                return `${this.s.toFixed(3)} + ${this.e12.toFixed(3)}e₁₂ + ${this.e31.toFixed(3)}e₃₁ + ${this.e23.toFixed(3)}e₂₃`;
            }
        }

        // Translator in PGA3D: T = 1 + (d·e0)/2 where d = dx*e1 + dy*e2 + dz*e3
        // Translation direction encoded in e01, e02, e03 bivectors
        class Translator {
            constructor(dx = 0, dy = 0, dz = 0) {
                this.dx = dx / 2;
                this.dy = dy / 2;
                this.dz = dz / 2;
            }

            apply(x, y, z) {
                return [x + 2*this.dx, y + 2*this.dy, z + 2*this.dz];
            }
        }

        // Motor = Translator * Rotor
        class Motor {
            constructor(rotor, translator) {
                this.R = rotor;
                this.T = translator;
            }

            static create(ax, ay, az, angle, dx, dy, dz) {
                return new Motor(
                    Rotor.fromAxisAngle(ax, ay, az, angle),
                    new Translator(dx, dy, dz)
                );
            }

            apply(x, y, z) {
                // First rotate, then translate
                const [rx, ry, rz] = this.R.apply(x, y, z);
                return this.T.apply(rx, ry, rz);
            }
        }

        // Compound rotor from Euler angles (ZYX convention)
        function rotorEuler(roll, pitch, yaw) {
            const Rx = Rotor.fromAxisAngle(1, 0, 0, roll);
            const Ry = Rotor.fromAxisAngle(0, 1, 0, pitch);
            const Rz = Rotor.fromAxisAngle(0, 0, 1, yaw);
            return Rz.mul(Ry.mul(Rx));
        }

        return { Rotor, Translator, Motor, rotorEuler };
    })();

    // ============================================================================
    // ANIMATION
    // ============================================================================

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W / 2, cy = H / 2;

    const params = { radius: 1.2, pitch: 0.4, spin: 2, helix: 0.7 };
    document.getElementById('radius').oninput = e => params.radius = +e.target.value;
    document.getElementById('pitch').oninput = e => params.pitch = +e.target.value;
    document.getElementById('spin').oninput = e => params.spin = +e.target.value;
    document.getElementById('helix').oninput = e => params.helix = +e.target.value;

    // Cube geometry
    const size = 0.35;
    const verts = [
        [-1,-1,-1], [1,-1,-1], [1,1,-1], [-1,1,-1],
        [-1,-1, 1], [1,-1, 1], [1,1, 1], [-1,1, 1]
    ].map(v => v.map(c => c * size));

    const faces = [
        { idx: [1,2,6,5], color: '#ff4466' },  // +X Red
        { idx: [0,4,7,3], color: '#44ff66' },  // -X Green
        { idx: [3,7,6,2], color: '#4466ff' },  // +Y Blue
        { idx: [0,1,5,4], color: '#ffff44' },  // -Y Yellow
        { idx: [4,5,6,7], color: '#ff44ff' },  // +Z Magenta
        { idx: [0,3,2,1], color: '#44ffff' }   // -Z Cyan
    ];

    const edges = [
        [0,1],[1,2],[2,3],[3,0],
        [4,5],[5,6],[6,7],[7,4],
        [0,4],[1,5],[2,6],[3,7]
    ];

    function project(x, y, z, d = 5) {
        const scale = 100;
        const p = d / (d - z);
        return [cx + x * scale * p, cy - y * scale * p, z];
    }

    let time = 0;

    function render() {
        time += 0.016;
        ctx.fillStyle = '#0a0a12';
        ctx.fillRect(0, 0, W, H);

        // Draw grid
        ctx.strokeStyle = '#1a1a2a';
        ctx.lineWidth = 1;
        for (let i = -5; i <= 5; i++) {
            const [x1, y1] = project(i * 0.4, 0, -2.5);
            const [x2, y2] = project(i * 0.4, 0, 2.5);
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            const [x3, y3] = project(-2.5, 0, i * 0.4);
            const [x4, y4] = project(2.5, 0, i * 0.4);
            ctx.beginPath(); ctx.moveTo(x3, y3); ctx.lineTo(x4, y4); ctx.stroke();
        }

        // Helix position
        const hAngle = time * params.helix;
        const px = params.radius * Math.cos(hAngle);
        const py = params.radius * Math.sin(hAngle);
        const pz = ((hAngle * params.pitch) % 5) - 2.5;

        // Draw helix trail
        ctx.beginPath();
        for (let i = 0; i < 80; i++) {
            const t = hAngle - i * 0.1;
            const tx = params.radius * Math.cos(t);
            const ty = params.radius * Math.sin(t);
            const tz = ((t * params.pitch) % 5) - 2.5;
            const [sx, sy] = project(tx, ty, tz);
            if (i === 0) ctx.moveTo(sx, sy);
            else ctx.lineTo(sx, sy);
        }
        ctx.strokeStyle = 'rgba(100, 150, 200, 0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Create compound rotor using PGA3D
        const ax = time * params.spin * 0.7;
        const ay = time * params.spin * 1.0;
        const az = time * params.spin * 0.5;
        const R = PGA3D.rotorEuler(ax, ay, az);

        // Transform vertices
        const transformed = verts.map(([x, y, z]) => {
            const [rx, ry, rz] = R.apply(x, y, z);
            return [rx + px, ry + py, rz + pz];
        });

        const projected = transformed.map(v => project(...v));

        // Sort faces by depth
        const sortedFaces = faces.map((f, i) => ({
            ...f,
            avgZ: f.idx.reduce((s, vi) => s + transformed[vi][2], 0) / 4
        })).sort((a, b) => a.avgZ - b.avgZ);

        // Draw faces
        sortedFaces.forEach(face => {
            ctx.beginPath();
            face.idx.forEach((vi, i) => {
                const [x, y] = projected[vi];
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.closePath();
            ctx.fillStyle = face.color;
            ctx.globalAlpha = 0.85;
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        });

        // Draw axes
        const origin = project(0, 0, 0);
        [[0.6,0,0,'#f55'], [0,0.6,0,'#5f5'], [0,0,0.6,'#55f']].forEach(([x,y,z,c]) => {
            const [ex, ey] = project(x, y, z);
            ctx.beginPath();
            ctx.moveTo(origin[0], origin[1]);
            ctx.lineTo(ex, ey);
            ctx.strokeStyle = c;
            ctx.lineWidth = 2;
            ctx.stroke();
        });

        // Debug info
        document.getElementById('debug').textContent = 
            `Rotor: ${R.toString()} | Pos: (${px.toFixed(2)}, ${py.toFixed(2)}, ${pz.toFixed(2)})`;

        requestAnimationFrame(render);
    }

    render();
    </script>
</body>
</html>
