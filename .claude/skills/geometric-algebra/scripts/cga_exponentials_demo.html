<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGA Exponentials: Point Pairs, Circles & Spheres</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #e8e8e8;
            min-height: 100vh;
        }
        h1 {
            text-align: center;
            color: #00d9ff;
            text-shadow: 0 0 20px rgba(0, 217, 255, 0.5);
            margin-bottom: 10px;
        }
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
        }
        .container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        .panel {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .panel h2 {
            color: #ff6b9d;
            margin-top: 0;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .panel h2 .icon { font-size: 1.5em; }
        canvas {
            width: 100%;
            height: 350px;
            border-radius: 12px;
            background: #000;
            display: block;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-group label {
            font-size: 0.85em;
            color: #aaa;
        }
        input[type="range"] {
            width: 120px;
            accent-color: #00d9ff;
        }
        select {
            background: rgba(0, 217, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(0, 217, 255, 0.3);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
        }
        .formula-box {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            border-left: 3px solid #7b68ee;
            margin-top: 15px;
        }
        .type-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
        }
        .elliptic { background: rgba(0, 200, 255, 0.3); color: #00d9ff; }
        .parabolic { background: rgba(255, 200, 0, 0.3); color: #ffd700; }
        .hyperbolic { background: rgba(255, 100, 100, 0.3); color: #ff6b6b; }
        .info-text {
            font-size: 0.85em;
            color: #888;
            margin-top: 10px;
            line-height: 1.5;
        }
        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.85em;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        .theory-section {
            background: rgba(123, 104, 238, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid rgba(123, 104, 238, 0.3);
        }
        .theory-section h3 {
            color: #7b68ee;
            margin-top: 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 0.9em;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        th {
            background: rgba(0, 217, 255, 0.15);
            color: #00d9ff;
        }
    </style>
</head>
<body>
    <h1>üåÄ CGA Exponentials: Transformation Generators</h1>
    <p class="subtitle">How exponentiating pairs of geometric primitives generates conformal transformations</p>

    <div class="container">
        <!-- Point Pair Panel -->
        <div class="panel">
            <h2><span class="icon">‚ö´‚ö´</span> Point Pair Exponential</h2>
            <canvas id="pointPairCanvas"></canvas>
            <div class="controls">
                <div class="control-group">
                    <label>Separation</label>
                    <input type="range" id="ppSeparation" min="0.5" max="3" step="0.1" value="1.5">
                </div>
                <div class="control-group">
                    <label>Speed</label>
                    <input type="range" id="ppSpeed" min="0.1" max="2" step="0.1" value="0.8">
                </div>
                <span class="type-badge hyperbolic">Hyperbolic (B¬≤ > 0)</span>
            </div>
            <div class="formula-box">
                PP = P‚ÇÅ ‚àß P‚ÇÇ &nbsp;‚Üí&nbsp; exp(t¬∑PP) = <strong>Booster</strong><br>
                cosh(t/2) + sinh(t/2)¬∑BÃÇ
            </div>
            <div class="legend">
                <div class="legend-item"><div class="legend-dot" style="background:#ff6b6b"></div> Source points</div>
                <div class="legend-item"><div class="legend-dot" style="background:#00ff88"></div> Flow lines</div>
                <div class="legend-item"><div class="legend-dot" style="background:#ffff00"></div> Test points</div>
            </div>
            <p class="info-text">Points flow along <strong>hyperbolic trajectories</strong> between the two source points. The transformation is non-compact ‚Äî points accelerate toward infinity along hyperbolas.</p>
        </div>

        <!-- Circle Pair Panel -->
        <div class="panel">
            <h2><span class="icon">‚≠ï‚≠ï</span> Circle Pair Exponential</h2>
            <canvas id="circlePairCanvas"></canvas>
            <div class="controls">
                <div class="control-group">
                    <label>Configuration</label>
                    <select id="circleConfig">
                        <option value="intersecting">Intersecting (Elliptic)</option>
                        <option value="tangent">Tangent (Parabolic)</option>
                        <option value="nested">Nested (Hyperbolic)</option>
                        <option value="disjoint">Disjoint (Hyperbolic)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Speed</label>
                    <input type="range" id="circleSpeed" min="0.1" max="2" step="0.1" value="0.7">
                </div>
            </div>
            <div class="formula-box" id="circleFormula">
                B = C‚ÇÅC‚ÇÇ‚Åª¬π &nbsp;‚Üí&nbsp; exp(Œ∏B/2) = <strong>Loxodrome</strong>
            </div>
            <div class="legend">
                <div class="legend-item"><div class="legend-dot" style="background:#00d9ff"></div> Circle 1</div>
                <div class="legend-item"><div class="legend-dot" style="background:#ff6b9d"></div> Circle 2</div>
                <div class="legend-item"><div class="legend-dot" style="background:#00ff88"></div> Flow spirals</div>
            </div>
            <p class="info-text" id="circleInfo">Intersecting circles generate <strong>rotation</strong> around their intersection points. Points spiral along loxodromes.</p>
        </div>

        <!-- Sphere Pair Panel (2D projection) -->
        <div class="panel">
            <h2><span class="icon">üîµüîµ</span> Sphere Pair Exponential (2D Circles)</h2>
            <canvas id="spherePairCanvas"></canvas>
            <div class="controls">
                <div class="control-group">
                    <label>Configuration</label>
                    <select id="sphereConfig">
                        <option value="concentric">Concentric ‚Üí Dilation</option>
                        <option value="intersecting">Intersecting ‚Üí Rotation</option>
                        <option value="tangent">Tangent ‚Üí Transversion</option>
                        <option value="disjoint">Disjoint ‚Üí Boost</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Speed</label>
                    <input type="range" id="sphereSpeed" min="0.1" max="2" step="0.1" value="0.6">
                </div>
            </div>
            <div class="formula-box" id="sphereFormula">
                B = S‚ÇÅS‚ÇÇ‚Åª¬π &nbsp;‚Üí&nbsp; exp(Œ∏B/2) = <strong>Dilation</strong>
            </div>
            <div class="legend">
                <div class="legend-item"><div class="legend-dot" style="background:#00d9ff"></div> Sphere 1</div>
                <div class="legend-item"><div class="legend-dot" style="background:#ff6b9d"></div> Sphere 2</div>
                <div class="legend-item"><div class="legend-dot" style="background:#00ff88"></div> Transformation flow</div>
            </div>
            <p class="info-text" id="sphereInfo">Concentric spheres generate <strong>pure dilation</strong> ‚Äî scaling from the common center.</p>
        </div>

        <!-- Combined Visualization -->
        <div class="panel">
            <h2><span class="icon">üåå</span> All Transformations Combined</h2>
            <canvas id="combinedCanvas"></canvas>
            <div class="controls">
                <div class="control-group">
                    <label>Show</label>
                    <select id="combinedShow">
                        <option value="all">All transformations</option>
                        <option value="rotation">Rotation only</option>
                        <option value="translation">Translation only</option>
                        <option value="dilation">Dilation only</option>
                        <option value="inversion">Inversion only</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Grid density</label>
                    <input type="range" id="gridDensity" min="3" max="10" step="1" value="6">
                </div>
            </div>
            <div class="formula-box">
                Full conformal group: SO(4,1) ‚âÖ exp(bivectors in CGA)<br>
                15 generators ‚Üí 15 transformation types
            </div>
            <p class="info-text">The <strong>conformal group</strong> in 3D is 15-dimensional. All transformations (rotation, translation, dilation, special conformal) arise from exponentiating CGA bivectors.</p>
        </div>
    </div>

    <div class="theory-section" style="max-width: 1400px; margin: 20px auto;">
        <h3>üìê The Unifying Pattern</h3>
        <table>
            <tr>
                <th>Primitive Pair</th>
                <th>Bivector B = X‚ÇÅX‚ÇÇ‚Åª¬π</th>
                <th>B¬≤ < 0 (Elliptic)</th>
                <th>B¬≤ = 0 (Parabolic)</th>
                <th>B¬≤ > 0 (Hyperbolic)</th>
            </tr>
            <tr>
                <td><strong>Point Pair</strong></td>
                <td>P‚ÇÅ ‚àß P‚ÇÇ</td>
                <td>‚Äî</td>
                <td>Null pair (translation)</td>
                <td>Booster (flow between points)</td>
            </tr>
            <tr>
                <td><strong>Circle Pair</strong></td>
                <td>C‚ÇÅC‚ÇÇ‚Åª¬π</td>
                <td>Intersecting ‚Üí Rotation</td>
                <td>Tangent ‚Üí Parabolic slide</td>
                <td>Nested/Disjoint ‚Üí Spiral</td>
            </tr>
            <tr>
                <td><strong>Sphere Pair</strong></td>
                <td>S‚ÇÅS‚ÇÇ‚Åª¬π</td>
                <td>Intersecting ‚Üí Rotation</td>
                <td>Tangent ‚Üí Transversion</td>
                <td>Concentric ‚Üí Dilation</td>
            </tr>
        </table>
        <p style="color: #aaa; margin-top: 15px;">
            <strong>Key insight:</strong> The discriminant Œî = (X‚ÇÅ¬∑X‚ÇÇ)¬≤ ‚àí X‚ÇÅ¬≤X‚ÇÇ¬≤ determines transformation type. 
            This is analogous to how the discriminant of a quadratic determines the nature of its roots!
        </p>
    </div>

    <script>
        // ============================================================================
        // CGA 2D Implementation for Visualization
        // ============================================================================
        
        const CGA2D = {
            // Embed Euclidean point into CGA
            point: function(x, y) {
                const sq = x*x + y*y;
                return { x, y, ninf: sq/2, no: 1, type: 'point' };
            },
            
            // Extract Euclidean coords
            coords: function(P) {
                if (P.no === 0) return { x: Infinity, y: Infinity };
                return { x: P.x / P.no, y: P.y / P.no };
            },
            
            // Circle from center and radius
            circle: function(cx, cy, r) {
                return { cx, cy, r, type: 'circle' };
            },
            
            // Check if point is inside circle
            pointInCircle: function(px, py, c) {
                const dx = px - c.cx, dy = py - c.cy;
                return dx*dx + dy*dy < c.r*c.r;
            },
            
            // Circle pair discriminant (determines transformation type)
            circleDiscriminant: function(c1, c2) {
                const dx = c1.cx - c2.cx, dy = c1.cy - c2.cy;
                const d = Math.sqrt(dx*dx + dy*dy);
                
                if (d < Math.abs(c1.r - c2.r)) return 1;  // Nested (hyperbolic)
                if (d > c1.r + c2.r) return 1;             // Disjoint (hyperbolic)
                if (Math.abs(d - (c1.r + c2.r)) < 0.01 || 
                    Math.abs(d - Math.abs(c1.r - c2.r)) < 0.01) return 0; // Tangent
                return -1;  // Intersecting (elliptic)
            },
            
            // Apply boost transformation
            applyBoost: function(px, py, p1x, p1y, p2x, p2y, t) {
                // Simplified: move point along hyperbola between p1 and p2
                const mx = (p1x + p2x) / 2, my = (p1y + p2y) / 2;
                const dx = p2x - p1x, dy = p2y - p1y;
                const len = Math.sqrt(dx*dx + dy*dy);
                const nx = dx/len, ny = dy/len;
                
                // Project point onto axis
                const projX = px - mx, projY = py - my;
                const along = projX * nx + projY * ny;
                const perp = -projX * ny + projY * nx;
                
                // Hyperbolic transformation
                const newAlong = along * Math.cosh(t) + Math.sign(along) * Math.sinh(t) * 0.5;
                
                return {
                    x: mx + newAlong * nx - perp * ny,
                    y: my + newAlong * ny + perp * nx
                };
            },
            
            // Apply loxodromic transformation (circle pair)
            applyLoxodrome: function(px, py, c1, c2, t, type) {
                if (type === 'elliptic') {
                    // Rotation around intersection
                    const angle = t;
                    const cx = (c1.cx + c2.cx) / 2;
                    const cy = (c1.cy + c2.cy) / 2;
                    const dx = px - cx, dy = py - cy;
                    return {
                        x: cx + dx * Math.cos(angle) - dy * Math.sin(angle),
                        y: cy + dx * Math.sin(angle) + dy * Math.cos(angle)
                    };
                } else if (type === 'parabolic') {
                    // Shear/translation along tangent
                    const tx = c2.cx - c1.cx, ty = c2.cy - c1.cy;
                    const len = Math.sqrt(tx*tx + ty*ty) || 1;
                    return {
                        x: px + t * 20 * ty / len,
                        y: py - t * 20 * tx / len
                    };
                } else {
                    // Spiral between circles
                    const cx = (c1.cx + c2.cx) / 2;
                    const cy = (c1.cy + c2.cy) / 2;
                    const dx = px - cx, dy = py - cy;
                    const r = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx);
                    const newR = r * Math.exp(t * 0.3);
                    const newAngle = angle + t * 0.5;
                    return {
                        x: cx + newR * Math.cos(newAngle),
                        y: cy + newR * Math.sin(newAngle)
                    };
                }
            },
            
            // Apply sphere pair transformation
            applySphereTransform: function(px, py, s1, s2, t, config) {
                const cx = (s1.cx + s2.cx) / 2;
                const cy = (s1.cy + s2.cy) / 2;
                
                if (config === 'concentric') {
                    // Pure dilation
                    const scale = Math.exp(t * 0.5);
                    return {
                        x: cx + (px - cx) * scale,
                        y: cy + (py - cy) * scale
                    };
                } else if (config === 'intersecting') {
                    // Rotation
                    const dx = px - cx, dy = py - cy;
                    return {
                        x: cx + dx * Math.cos(t) - dy * Math.sin(t),
                        y: cy + dx * Math.sin(t) + dy * Math.cos(t)
                    };
                } else if (config === 'tangent') {
                    // Transversion (special conformal)
                    const ax = (s2.cx - s1.cx) * 0.01;
                    const ay = (s2.cy - s1.cy) * 0.01;
                    const r2 = px*px + py*py;
                    const denom = 1 + 2*t*(ax*px + ay*py) + t*t*(ax*ax + ay*ay)*r2;
                    if (Math.abs(denom) < 0.01) return { x: px, y: py };
                    return {
                        x: (px + t * ax * r2) / denom,
                        y: (py + t * ay * r2) / denom
                    };
                } else {
                    // Boost-like
                    const dx = s2.cx - s1.cx, dy = s2.cy - s1.cy;
                    const len = Math.sqrt(dx*dx + dy*dy) || 1;
                    const factor = Math.exp(t * 0.3) - 1;
                    return {
                        x: px + factor * dx / len * 30,
                        y: py + factor * dy / len * 30
                    };
                }
            }
        };

        // ============================================================================
        // Visualization Helpers
        // ============================================================================
        
        function setupCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            return { ctx, width: rect.width, height: rect.height };
        }
        
        function drawCircle(ctx, cx, cy, r, color, lineWidth = 2, dashed = false) {
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            if (dashed) ctx.setLineDash([5, 5]);
            else ctx.setLineDash([]);
            ctx.stroke();
        }
        
        function drawPoint(ctx, x, y, r, color) {
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        function drawArrow(ctx, x1, y1, x2, y2, color) {
            const dx = x2 - x1, dy = y2 - y1;
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len < 5) return;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            // Arrowhead
            const angle = Math.atan2(dy, dx);
            const headLen = 8;
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLen * Math.cos(angle - 0.3), y2 - headLen * Math.sin(angle - 0.3));
            ctx.lineTo(x2 - headLen * Math.cos(angle + 0.3), y2 - headLen * Math.sin(angle + 0.3));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }

        // ============================================================================
        // Point Pair Visualization
        // ============================================================================
        
        let ppTime = 0;
        function animatePointPair() {
            const canvas = document.getElementById('pointPairCanvas');
            const { ctx, width, height } = setupCanvas(canvas);
            
            const sep = parseFloat(document.getElementById('ppSeparation').value);
            const speed = parseFloat(document.getElementById('ppSpeed').value);
            
            const cx = width / 2, cy = height / 2;
            const p1 = { x: cx - sep * 60, y: cy };
            const p2 = { x: cx + sep * 60, y: cy };
            
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Draw hyperbolic flow field
            ctx.globalAlpha = 0.3;
            for (let i = -3; i <= 3; i++) {
                for (let j = -2; j <= 2; j++) {
                    if (i === 0 && j === 0) continue;
                    const px = cx + i * 50;
                    const py = cy + j * 40;
                    
                    const result = CGA2D.applyBoost(px, py, p1.x, p1.y, p2.x, p2.y, 0.3);
                    drawArrow(ctx, px, py, result.x, result.y, '#00ff88');
                }
            }
            ctx.globalAlpha = 1;
            
            // Draw animated flow lines
            const numLines = 8;
            for (let i = 0; i < numLines; i++) {
                const startY = cy + (i - numLines/2 + 0.5) * 30;
                
                ctx.beginPath();
                let prevX = p1.x - 30, prevY = startY;
                ctx.moveTo(prevX, prevY);
                
                for (let t = -1; t <= 1; t += 0.05) {
                    const animT = t + Math.sin(ppTime * speed) * 0.5;
                    const result = CGA2D.applyBoost(p1.x - 30, startY, p1.x, p1.y, p2.x, p2.y, animT);
                    ctx.lineTo(result.x, result.y);
                }
                
                ctx.strokeStyle = `hsla(${120 + i * 20}, 80%, 60%, 0.6)`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Draw test points moving along flow
            for (let i = 0; i < 5; i++) {
                const phase = (ppTime * speed + i * 0.5) % 3 - 1.5;
                const startY = cy + (i - 2) * 35;
                const result = CGA2D.applyBoost(cx - 80, startY, p1.x, p1.y, p2.x, p2.y, phase);
                drawPoint(ctx, result.x, result.y, 6, '#ffff00');
            }
            
            // Draw source points
            drawPoint(ctx, p1.x, p1.y, 10, '#ff6b6b');
            drawPoint(ctx, p2.x, p2.y, 10, '#ff6b6b');
            
            // Labels
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '14px sans-serif';
            ctx.fillText('P‚ÇÅ', p1.x - 20, p1.y - 15);
            ctx.fillText('P‚ÇÇ', p2.x + 8, p2.y - 15);
            
            ppTime += 0.02;
            requestAnimationFrame(animatePointPair);
        }

        // ============================================================================
        // Circle Pair Visualization
        // ============================================================================
        
        let circleTime = 0;
        function animateCirclePair() {
            const canvas = document.getElementById('circlePairCanvas');
            const { ctx, width, height } = setupCanvas(canvas);
            
            const config = document.getElementById('circleConfig').value;
            const speed = parseFloat(document.getElementById('circleSpeed').value);
            
            const cx = width / 2, cy = height / 2;
            let c1, c2, type, info;
            
            switch(config) {
                case 'intersecting':
                    c1 = { cx: cx - 40, cy: cy, r: 80 };
                    c2 = { cx: cx + 40, cy: cy, r: 80 };
                    type = 'elliptic';
                    info = 'Intersecting circles generate <strong>rotation</strong> around their intersection points.';
                    break;
                case 'tangent':
                    c1 = { cx: cx - 60, cy: cy, r: 60 };
                    c2 = { cx: cx + 60, cy: cy, r: 60 };
                    type = 'parabolic';
                    info = 'Tangent circles generate <strong>parabolic</strong> flow ‚Äî a shear along the tangent point.';
                    break;
                case 'nested':
                    c1 = { cx: cx, cy: cy, r: 100 };
                    c2 = { cx: cx + 20, cy: cy, r: 40 };
                    type = 'hyperbolic';
                    info = 'Nested circles generate <strong>logarithmic spiral</strong> ‚Äî points spiral inward or outward.';
                    break;
                case 'disjoint':
                    c1 = { cx: cx - 90, cy: cy, r: 50 };
                    c2 = { cx: cx + 90, cy: cy, r: 50 };
                    type = 'hyperbolic';
                    info = 'Disjoint circles generate <strong>hyperbolic spiral</strong> flow between the circles.';
                    break;
            }
            
            document.getElementById('circleInfo').innerHTML = info;
            
            const badgeClass = type;
            const formulaText = type === 'elliptic' 
                ? 'B¬≤ < 0 ‚Üí exp(Œ∏B/2) = cos(Œ∏/2) + sin(Œ∏/2)B'
                : type === 'parabolic'
                ? 'B¬≤ = 0 ‚Üí exp(Œ∏B/2) = 1 + (Œ∏/2)B'
                : 'B¬≤ > 0 ‚Üí exp(Œ∏B/2) = cosh(Œ∏/2) + sinh(Œ∏/2)B';
            document.getElementById('circleFormula').innerHTML = `B = C‚ÇÅC‚ÇÇ‚Åª¬π &nbsp;‚Üí&nbsp; <span class="type-badge ${badgeClass}">${type}</span><br>${formulaText}`;
            
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Draw circles
            drawCircle(ctx, c1.cx, c1.cy, c1.r, '#00d9ff', 3);
            drawCircle(ctx, c2.cx, c2.cy, c2.r, '#ff6b9d', 3);
            
            // Draw flow field
            ctx.globalAlpha = 0.4;
            const gridStep = 40;
            for (let x = gridStep; x < width; x += gridStep) {
                for (let y = gridStep; y < height; y += gridStep) {
                    const result = CGA2D.applyLoxodrome(x, y, c1, c2, 0.2, type);
                    if (isFinite(result.x) && isFinite(result.y)) {
                        drawArrow(ctx, x, y, result.x, result.y, '#00ff88');
                    }
                }
            }
            ctx.globalAlpha = 1;
            
            // Animated flow lines
            const numTrails = 12;
            for (let i = 0; i < numTrails; i++) {
                const angle = (i / numTrails) * Math.PI * 2;
                const startR = (c1.r + c2.r) / 2;
                const startX = cx + Math.cos(angle) * startR;
                const startY = cy + Math.sin(angle) * startR;
                
                ctx.beginPath();
                let px = startX, py = startY;
                ctx.moveTo(px, py);
                
                for (let t = 0; t < 20; t++) {
                    const phase = (circleTime * speed + t * 0.1) * 0.3;
                    const result = CGA2D.applyLoxodrome(px, py, c1, c2, 0.08, type);
                    if (!isFinite(result.x) || !isFinite(result.y)) break;
                    if (result.x < 0 || result.x > width || result.y < 0 || result.y > height) break;
                    ctx.lineTo(result.x, result.y);
                    px = result.x;
                    py = result.y;
                }
                
                ctx.strokeStyle = `hsla(${120 + i * 10}, 70%, 55%, 0.7)`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Moving test points
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 + circleTime * speed * 0.5;
                const r = 60;
                let px = cx + Math.cos(angle) * r;
                let py = cy + Math.sin(angle) * r;
                
                for (let t = 0; t < 5; t++) {
                    const result = CGA2D.applyLoxodrome(px, py, c1, c2, 0.15, type);
                    px = result.x;
                    py = result.y;
                }
                
                drawPoint(ctx, px, py, 5, '#ffff00');
            }
            
            // Labels
            ctx.fillStyle = '#00d9ff';
            ctx.font = '14px sans-serif';
            ctx.fillText('C‚ÇÅ', c1.cx - c1.r - 20, c1.cy);
            ctx.fillStyle = '#ff6b9d';
            ctx.fillText('C‚ÇÇ', c2.cx + c2.r + 8, c2.cy);
            
            circleTime += 0.02;
            requestAnimationFrame(animateCirclePair);
        }

        // ============================================================================
        // Sphere Pair Visualization (2D projection)
        // ============================================================================
        
        let sphereTime = 0;
        function animateSpherePair() {
            const canvas = document.getElementById('spherePairCanvas');
            const { ctx, width, height } = setupCanvas(canvas);
            
            const config = document.getElementById('sphereConfig').value;
            const speed = parseFloat(document.getElementById('sphereSpeed').value);
            
            const cx = width / 2, cy = height / 2;
            let s1, s2, info, badge;
            
            switch(config) {
                case 'concentric':
                    s1 = { cx: cx, cy: cy, r: 60 };
                    s2 = { cx: cx, cy: cy, r: 120 };
                    info = 'Concentric spheres generate <strong>pure dilation</strong> ‚Äî scaling from the common center.';
                    badge = 'hyperbolic';
                    break;
                case 'intersecting':
                    s1 = { cx: cx - 50, cy: cy, r: 90 };
                    s2 = { cx: cx + 50, cy: cy, r: 90 };
                    info = 'Intersecting spheres generate <strong>rotation</strong> around their circle of intersection.';
                    badge = 'elliptic';
                    break;
                case 'tangent':
                    s1 = { cx: cx - 70, cy: cy, r: 70 };
                    s2 = { cx: cx + 70, cy: cy, r: 70 };
                    info = 'Tangent spheres generate <strong>transversion</strong> (special conformal transformation).';
                    badge = 'parabolic';
                    break;
                case 'disjoint':
                    s1 = { cx: cx - 100, cy: cy, r: 50 };
                    s2 = { cx: cx + 100, cy: cy, r: 50 };
                    info = 'Disjoint spheres generate a <strong>boost-like</strong> hyperbolic flow.';
                    badge = 'hyperbolic';
                    break;
            }
            
            document.getElementById('sphereInfo').innerHTML = info;
            document.getElementById('sphereFormula').innerHTML = 
                `B = S‚ÇÅS‚ÇÇ‚Åª¬π &nbsp;‚Üí&nbsp; <span class="type-badge ${badge}">${badge}</span><br>` +
                `Generates: ${config === 'concentric' ? 'Dilation' : config === 'intersecting' ? 'Rotation' : config === 'tangent' ? 'Transversion' : 'Boost'}`;
            
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Draw spheres (circles in 2D)
            drawCircle(ctx, s1.cx, s1.cy, s1.r, '#00d9ff', 3);
            drawCircle(ctx, s2.cx, s2.cy, s2.r, '#ff6b9d', 3);
            
            // Draw flow field
            ctx.globalAlpha = 0.4;
            const gridStep = 35;
            for (let x = gridStep; x < width; x += gridStep) {
                for (let y = gridStep; y < height; y += gridStep) {
                    const result = CGA2D.applySphereTransform(x, y, s1, s2, 0.3, config);
                    if (isFinite(result.x) && isFinite(result.y)) {
                        const dx = result.x - x, dy = result.y - y;
                        const len = Math.sqrt(dx*dx + dy*dy);
                        if (len > 2 && len < 100) {
                            drawArrow(ctx, x, y, result.x, result.y, '#00ff88');
                        }
                    }
                }
            }
            ctx.globalAlpha = 1;
            
            // Animated flow trails
            const numTrails = 16;
            for (let i = 0; i < numTrails; i++) {
                const angle = (i / numTrails) * Math.PI * 2;
                let px = cx + Math.cos(angle) * 80;
                let py = cy + Math.sin(angle) * 80;
                
                ctx.beginPath();
                ctx.moveTo(px, py);
                
                for (let t = 0; t < 30; t++) {
                    const phase = Math.sin(sphereTime * speed + t * 0.1) * 0.15;
                    const result = CGA2D.applySphereTransform(px, py, s1, s2, phase, config);
                    if (!isFinite(result.x) || !isFinite(result.y)) break;
                    if (result.x < -50 || result.x > width + 50 || result.y < -50 || result.y > height + 50) break;
                    ctx.lineTo(result.x, result.y);
                    px = result.x;
                    py = result.y;
                }
                
                ctx.strokeStyle = `hsla(${100 + i * 15}, 70%, 55%, 0.6)`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Moving test points
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const r = 70 + Math.sin(sphereTime * speed + i) * 20;
                let px = cx + Math.cos(angle) * r;
                let py = cy + Math.sin(angle) * r;
                
                const t = Math.sin(sphereTime * speed * 2) * 0.4;
                const result = CGA2D.applySphereTransform(px, py, s1, s2, t, config);
                
                drawPoint(ctx, result.x, result.y, 5, '#ffff00');
            }
            
            // Labels
            ctx.fillStyle = '#00d9ff';
            ctx.font = '14px sans-serif';
            ctx.fillText('S‚ÇÅ', s1.cx - s1.r - 20, s1.cy);
            ctx.fillStyle = '#ff6b9d';
            ctx.fillText('S‚ÇÇ', s2.cx + s2.r + 8, s2.cy);
            
            sphereTime += 0.02;
            requestAnimationFrame(animateSpherePair);
        }

        // ============================================================================
        // Combined Visualization
        // ============================================================================
        
        let combinedTime = 0;
        function animateCombined() {
            const canvas = document.getElementById('combinedCanvas');
            const { ctx, width, height } = setupCanvas(canvas);
            
            const show = document.getElementById('combinedShow').value;
            const density = parseInt(document.getElementById('gridDensity').value);
            
            const cx = width / 2, cy = height / 2;
            
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Create grid of points
            const points = [];
            const step = Math.min(width, height) / (density + 1);
            for (let i = 1; i <= density; i++) {
                for (let j = 1; j <= density; j++) {
                    points.push({
                        x: i * step,
                        y: j * step,
                        ox: i * step,
                        oy: j * step
                    });
                }
            }
            
            // Apply transformation based on selection
            const t = combinedTime * 0.5;
            
            points.forEach(p => {
                let nx = p.ox, ny = p.oy;
                
                if (show === 'all' || show === 'rotation') {
                    // Rotation
                    const dx = nx - cx, dy = ny - cy;
                    const angle = t * 0.5;
                    nx = cx + dx * Math.cos(angle) - dy * Math.sin(angle);
                    ny = cy + dx * Math.sin(angle) + dy * Math.cos(angle);
                }
                
                if (show === 'all' || show === 'translation') {
                    // Translation
                    nx += Math.sin(t) * 30;
                    ny += Math.cos(t * 0.7) * 20;
                }
                
                if (show === 'all' || show === 'dilation') {
                    // Dilation
                    const scale = 1 + 0.3 * Math.sin(t * 0.8);
                    nx = cx + (nx - cx) * scale;
                    ny = cy + (ny - cy) * scale;
                }
                
                if (show === 'all' || show === 'inversion') {
                    // Special conformal (inversion-like)
                    const ax = 0.003 * Math.sin(t * 0.6);
                    const ay = 0.003 * Math.cos(t * 0.6);
                    const px = nx - cx, py = ny - cy;
                    const r2 = px*px + py*py;
                    const denom = 1 + 2*(ax*px + ay*py) + (ax*ax + ay*ay)*r2;
                    if (Math.abs(denom) > 0.1) {
                        nx = cx + (px + ax * r2) / denom;
                        ny = cy + (py + ay * r2) / denom;
                    }
                }
                
                p.x = nx;
                p.y = ny;
            });
            
            // Draw grid connections
            ctx.strokeStyle = 'rgba(0, 217, 255, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < density; i++) {
                for (let j = 0; j < density; j++) {
                    const idx = i * density + j;
                    const p = points[idx];
                    
                    // Horizontal connection
                    if (j < density - 1) {
                        const p2 = points[idx + 1];
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                    
                    // Vertical connection
                    if (i < density - 1) {
                        const p2 = points[idx + density];
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw points
            points.forEach((p, i) => {
                const hue = (i / points.length) * 360;
                drawPoint(ctx, p.x, p.y, 4, `hsl(${hue}, 80%, 60%)`);
            });
            
            // Draw center
            drawPoint(ctx, cx, cy, 6, '#ffffff');
            
            // Info text
            ctx.fillStyle = '#888';
            ctx.font = '12px sans-serif';
            ctx.fillText(`Showing: ${show}`, 10, height - 10);
            
            combinedTime += 0.02;
            requestAnimationFrame(animateCombined);
        }

        // Start all animations
        animatePointPair();
        animateCirclePair();
        animateSpherePair();
        animateCombined();
    </script>
</body>
</html>
