<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGA for Curved Meshes: Circle & Sphere Fitting</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #e8e8e8;
            min-height: 100vh;
        }
        h1 {
            text-align: center;
            color: #00d9ff;
            text-shadow: 0 0 20px rgba(0, 217, 255, 0.5);
            margin-bottom: 5px;
        }
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 25px;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; }
        }
        .panel {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .panel h2 {
            color: #ff6b9d;
            margin-top: 0;
            font-size: 1.2em;
        }
        canvas {
            width: 100%;
            height: 300px;
            border-radius: 12px;
            background: #000;
            display: block;
            cursor: crosshair;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .control-group label {
            font-size: 0.8em;
            color: #aaa;
        }
        input[type="range"] {
            width: 100px;
            accent-color: #00d9ff;
        }
        select, button {
            background: rgba(0, 217, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(0, 217, 255, 0.3);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
        }
        button:hover {
            background: rgba(0, 217, 255, 0.2);
        }
        .formula-box {
            background: rgba(0, 0, 0, 0.4);
            padding: 10px 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            border-left: 3px solid #7b68ee;
            margin-top: 12px;
        }
        .info-text {
            font-size: 0.85em;
            color: #999;
            margin-top: 10px;
            line-height: 1.5;
        }
        .curvature-display {
            display: flex;
            gap: 20px;
            margin-top: 12px;
            flex-wrap: wrap;
        }
        .curvature-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 8px;
            text-align: center;
        }
        .curvature-item .value {
            font-size: 1.4em;
            font-weight: bold;
            color: #00d9ff;
        }
        .curvature-item .label {
            font-size: 0.75em;
            color: #888;
        }
        .full-width {
            grid-column: 1 / -1;
        }
        .theory-box {
            background: rgba(123, 104, 238, 0.1);
            border: 1px solid rgba(123, 104, 238, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
        }
        .theory-box h3 {
            color: #7b68ee;
            margin: 0 0 10px 0;
            font-size: 1em;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        th { color: #00d9ff; }
        .color-pos { color: #ff6b6b; }
        .color-neg { color: #6b9fff; }
        .color-zero { color: #88ff88; }
    </style>
</head>
<body>
    <h1>üîÆ CGA for Curved Meshes</h1>
    <p class="subtitle">Circle fitting for 2D curvature ‚Ä¢ Sphere fitting for 3D principal curvatures</p>

    <div class="container">
        <!-- 2D Curve: Circle Fitting -->
        <div class="panel">
            <h2>üìê 2D Curve: Osculating Circle</h2>
            <canvas id="curve2dCanvas"></canvas>
            <div class="controls">
                <div class="control-group">
                    <label>Curve Type</label>
                    <select id="curveType">
                        <option value="sine">Sine wave</option>
                        <option value="circle">Circle (r=80)</option>
                        <option value="spiral">Spiral</option>
                        <option value="custom">Custom (click)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Sample Point</label>
                    <input type="range" id="curveT" min="0" max="100" value="50">
                </div>
            </div>
            <div class="curvature-display">
                <div class="curvature-item">
                    <div class="value" id="kappa2d">0.00</div>
                    <div class="label">Œ∫ (curvature)</div>
                </div>
                <div class="curvature-item">
                    <div class="value" id="radius2d">‚àû</div>
                    <div class="label">r (radius)</div>
                </div>
            </div>
            <div class="formula-box">
                C = P‚ÇÅ ‚àß P‚ÇÇ ‚àß P‚ÇÉ<br>
                Œ∫ = 1/radius(C) = 2|P‚ÇÅ ‚àß P‚ÇÇ ‚àß P‚ÇÉ| / |P‚ÇÅ-P‚ÇÇ||P‚ÇÇ-P‚ÇÉ||P‚ÇÉ-P‚ÇÅ|
            </div>
        </div>

        <!-- 3D Surface: Sphere Fitting -->
        <div class="panel">
            <h2>üåê 3D Surface: Principal Curvatures</h2>
            <canvas id="surface3dCanvas"></canvas>
            <div class="controls">
                <div class="control-group">
                    <label>Surface</label>
                    <select id="surfaceType">
                        <option value="sphere">Sphere (K > 0)</option>
                        <option value="cylinder">Cylinder (K = 0)</option>
                        <option value="saddle">Saddle (K < 0)</option>
                        <option value="torus">Torus (mixed)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Position</label>
                    <input type="range" id="surfacePos" min="0" max="100" value="30">
                </div>
            </div>
            <div class="curvature-display">
                <div class="curvature-item">
                    <div class="value" id="k1">0.00</div>
                    <div class="label">Œ∫‚ÇÅ (max)</div>
                </div>
                <div class="curvature-item">
                    <div class="value" id="k2">0.00</div>
                    <div class="label">Œ∫‚ÇÇ (min)</div>
                </div>
                <div class="curvature-item">
                    <div class="value" id="gaussK">0.00</div>
                    <div class="label">K = Œ∫‚ÇÅŒ∫‚ÇÇ</div>
                </div>
                <div class="curvature-item">
                    <div class="value" id="meanH">0.00</div>
                    <div class="label">H = (Œ∫‚ÇÅ+Œ∫‚ÇÇ)/2</div>
                </div>
            </div>
            <div class="formula-box">
                S = P‚ÇÅ ‚àß P‚ÇÇ ‚àß P‚ÇÉ ‚àß P‚ÇÑ ‚Üí principal sphere<br>
                Œ∫‚ÇÅ, Œ∫‚ÇÇ from two orthogonal osculating circles
            </div>
        </div>

        <!-- Mesh Curvature Visualization -->
        <div class="panel full-width">
            <h2>üî∫ Mesh Curvature via CGA Circle Fitting</h2>
            <canvas id="meshCanvas"></canvas>
            <div class="controls">
                <div class="control-group">
                    <label>Mesh</label>
                    <select id="meshType">
                        <option value="wave">Wavy surface</option>
                        <option value="bump">Gaussian bump</option>
                        <option value="saddle">Monkey saddle</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Show</label>
                    <select id="meshShow">
                        <option value="gaussian">Gaussian K</option>
                        <option value="mean">Mean H</option>
                        <option value="circles">Osculating circles</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Resolution</label>
                    <input type="range" id="meshRes" min="5" max="20" value="10">
                </div>
                <button id="meshRotate">‚ü≥ Rotate</button>
            </div>
            <p class="info-text">
                <span class="color-pos">Red = positive curvature (convex)</span> ‚Ä¢ 
                <span class="color-neg">Blue = negative curvature (saddle)</span> ‚Ä¢ 
                <span class="color-zero">Green = zero curvature (flat)</span>
            </p>
        </div>

        <!-- Applications Theory -->
        <div class="panel full-width">
            <div class="theory-box">
                <h3>üéØ Practical Applications of CGA for Meshes</h3>
                <table>
                    <tr>
                        <th>Application</th>
                        <th>CGA Operation</th>
                        <th>Benefit</th>
                    </tr>
                    <tr>
                        <td><strong>Curvature Estimation</strong></td>
                        <td>Circle/sphere through vertex neighbors</td>
                        <td>Robust to noise, no derivatives needed</td>
                    </tr>
                    <tr>
                        <td><strong>Feature Detection</strong></td>
                        <td>Discriminant of fitted circles</td>
                        <td>Detects ridges, valleys, corners</td>
                    </tr>
                    <tr>
                        <td><strong>Adaptive Remeshing</strong></td>
                        <td>Curvature ‚Üí local edge length</td>
                        <td>More triangles where curved, fewer where flat</td>
                    </tr>
                    <tr>
                        <td><strong>Smoothing Flow</strong></td>
                        <td>exp(circle pair) interpolation</td>
                        <td>Conformal (angle-preserving) smoothing</td>
                    </tr>
                    <tr>
                        <td><strong>Mesh Deformation</strong></td>
                        <td>Sphere pair exponentials</td>
                        <td>Bend/twist while preserving local angles</td>
                    </tr>
                </table>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // CGA Circle/Sphere Fitting Utilities
        // ============================================================================
        
        const CGA = {
            // Fit circle through 3 points, return center and radius
            circleThrough3: function(p1, p2, p3) {
                // Using circumcircle formula
                const ax = p1[0], ay = p1[1];
                const bx = p2[0], by = p2[1];
                const cx = p3[0], cy = p3[1];
                
                const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
                if (Math.abs(d) < 1e-10) {
                    return { center: [0, 0], radius: Infinity, valid: false };
                }
                
                const ux = ((ax*ax + ay*ay) * (by - cy) + (bx*bx + by*by) * (cy - ay) + (cx*cx + cy*cy) * (ay - by)) / d;
                const uy = ((ax*ax + ay*ay) * (cx - bx) + (bx*bx + by*by) * (ax - cx) + (cx*cx + cy*cy) * (bx - ax)) / d;
                
                const radius = Math.sqrt((ax - ux)**2 + (ay - uy)**2);
                
                return { center: [ux, uy], radius, valid: true };
            },
            
            // Curvature from 3 consecutive points on curve
            curvatureAt: function(p1, p2, p3) {
                const circle = this.circleThrough3(p1, p2, p3);
                if (!circle.valid || circle.radius > 10000) {
                    return { kappa: 0, radius: Infinity, center: p2 };
                }
                
                // Determine sign from cross product (left vs right turn)
                const v1 = [p2[0] - p1[0], p2[1] - p1[1]];
                const v2 = [p3[0] - p2[0], p3[1] - p2[1]];
                const cross = v1[0] * v2[1] - v1[1] * v2[0];
                const sign = cross >= 0 ? 1 : -1;
                
                return {
                    kappa: sign / circle.radius,
                    radius: circle.radius,
                    center: circle.center
                };
            },
            
            // Sphere through 4 points (3D)
            sphereThrough4: function(p1, p2, p3, p4) {
                // Simplified: use least squares fit
                // For demo, we'll compute analytically for special cases
                const cx = (p1[0] + p2[0] + p3[0] + p4[0]) / 4;
                const cy = (p1[1] + p2[1] + p3[1] + p4[1]) / 4;
                const cz = (p1[2] + p2[2] + p3[2] + p4[2]) / 4;
                
                const r = Math.sqrt((p1[0]-cx)**2 + (p1[1]-cy)**2 + (p1[2]-cz)**2);
                
                return { center: [cx, cy, cz], radius: r };
            },
            
            // Principal curvatures from local neighborhood
            principalCurvatures: function(point, neighbors, normal) {
                // Fit osculating circles in two orthogonal directions
                // This is a simplified version
                
                if (neighbors.length < 4) {
                    return { k1: 0, k2: 0, K: 0, H: 0 };
                }
                
                // Project neighbors to tangent plane and compute curvature in two directions
                // For this demo, we'll use a simpler approximation
                
                let k1 = 0, k2 = 0;
                
                // Sample curvature in different directions
                const curvatures = [];
                for (let i = 0; i < neighbors.length; i++) {
                    const j = (i + 1) % neighbors.length;
                    const circle = this.circleThrough3(
                        [neighbors[i][0], neighbors[i][2]],
                        [point[0], point[2]],
                        [neighbors[j][0], neighbors[j][2]]
                    );
                    if (circle.valid && circle.radius < 1000) {
                        curvatures.push(1 / circle.radius);
                    }
                }
                
                if (curvatures.length >= 2) {
                    curvatures.sort((a, b) => b - a);
                    k1 = curvatures[0];
                    k2 = curvatures[curvatures.length - 1];
                }
                
                return {
                    k1, k2,
                    K: k1 * k2,  // Gaussian
                    H: (k1 + k2) / 2  // Mean
                };
            }
        };

        // ============================================================================
        // Canvas Setup
        // ============================================================================
        
        function setupCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            return { ctx, width: rect.width, height: rect.height };
        }

        // ============================================================================
        // 2D Curve Visualization
        // ============================================================================
        
        let customPoints = [];
        
        function animate2DCurve() {
            const canvas = document.getElementById('curve2dCanvas');
            const { ctx, width, height } = setupCanvas(canvas);
            
            const curveType = document.getElementById('curveType').value;
            const t = parseInt(document.getElementById('curveT').value) / 100;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            const cx = width / 2, cy = height / 2;
            
            // Generate curve points
            let curvePoints = [];
            const numPoints = 100;
            
            if (curveType === 'sine') {
                for (let i = 0; i <= numPoints; i++) {
                    const x = (i / numPoints) * (width - 40) + 20;
                    const y = cy + Math.sin((i / numPoints) * Math.PI * 3) * 80;
                    curvePoints.push([x, y]);
                }
            } else if (curveType === 'circle') {
                for (let i = 0; i <= numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    const x = cx + Math.cos(angle) * 80;
                    const y = cy + Math.sin(angle) * 80;
                    curvePoints.push([x, y]);
                }
            } else if (curveType === 'spiral') {
                for (let i = 0; i <= numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 4;
                    const r = 20 + (i / numPoints) * 80;
                    const x = cx + Math.cos(angle) * r;
                    const y = cy + Math.sin(angle) * r;
                    curvePoints.push([x, y]);
                }
            } else if (curveType === 'custom') {
                curvePoints = customPoints.length > 2 ? customPoints : [
                    [50, cy], [width/2, cy - 50], [width - 50, cy]
                ];
            }
            
            // Draw curve
            if (curvePoints.length > 1) {
                ctx.beginPath();
                ctx.moveTo(curvePoints[0][0], curvePoints[0][1]);
                for (let i = 1; i < curvePoints.length; i++) {
                    ctx.lineTo(curvePoints[i][0], curvePoints[i][1]);
                }
                ctx.strokeStyle = '#00d9ff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Find sample point and neighbors
            const idx = Math.floor(t * (curvePoints.length - 3)) + 1;
            if (curvePoints.length > 2 && idx > 0 && idx < curvePoints.length - 1) {
                const p1 = curvePoints[idx - 1];
                const p2 = curvePoints[idx];
                const p3 = curvePoints[idx + 1];
                
                // Compute curvature
                const curv = CGA.curvatureAt(p1, p2, p3);
                
                // Draw osculating circle
                if (curv.radius < 500 && curv.radius > 0) {
                    ctx.beginPath();
                    ctx.arc(curv.center[0], curv.center[1], curv.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 107, 157, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw center
                    ctx.beginPath();
                    ctx.arc(curv.center[0], curv.center[1], 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#ff6b9d';
                    ctx.fill();
                    
                    // Draw radius line
                    ctx.beginPath();
                    ctx.moveTo(p2[0], p2[1]);
                    ctx.lineTo(curv.center[0], curv.center[1]);
                    ctx.strokeStyle = 'rgba(255, 107, 157, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                // Draw 3 sample points
                ctx.fillStyle = '#ffff00';
                [p1, p2, p3].forEach((p, i) => {
                    ctx.beginPath();
                    ctx.arc(p[0], p[1], i === 1 ? 8 : 5, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Labels
                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                ctx.fillText('P‚ÇÅ', p1[0] - 15, p1[1] - 10);
                ctx.fillText('P‚ÇÇ', p2[0] + 10, p2[1] - 10);
                ctx.fillText('P‚ÇÉ', p3[0] + 10, p3[1] + 15);
                
                // Update displays
                document.getElementById('kappa2d').textContent = curv.kappa.toFixed(4);
                document.getElementById('radius2d').textContent = 
                    curv.radius > 1000 ? '‚àû' : curv.radius.toFixed(1);
                
                // Color code kappa
                const kappaEl = document.getElementById('kappa2d');
                if (curv.kappa > 0.001) kappaEl.style.color = '#ff6b6b';
                else if (curv.kappa < -0.001) kappaEl.style.color = '#6b9fff';
                else kappaEl.style.color = '#88ff88';
            }
            
            requestAnimationFrame(animate2DCurve);
        }

        // Click handler for custom curve
        document.getElementById('curve2dCanvas').addEventListener('click', function(e) {
            if (document.getElementById('curveType').value !== 'custom') return;
            
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            customPoints.push([x, y]);
            if (customPoints.length > 20) customPoints.shift();
        });

        // ============================================================================
        // 3D Surface Visualization
        // ============================================================================
        
        let surfaceAngle = 0;
        
        function animate3DSurface() {
            const canvas = document.getElementById('surface3dCanvas');
            const { ctx, width, height } = setupCanvas(canvas);
            
            const surfaceType = document.getElementById('surfaceType').value;
            const pos = parseInt(document.getElementById('surfacePos').value) / 100;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            const cx = width / 2, cy = height / 2;
            
            // Surface function and its curvatures
            let surfaceFunc, k1, k2;
            let sampleU = pos, sampleV = 0.5;
            
            switch(surfaceType) {
                case 'sphere':
                    // Sphere: K = 1/r¬≤, H = 1/r
                    k1 = k2 = 0.02;  // radius ~50
                    break;
                case 'cylinder':
                    // Cylinder: K = 0, H = 1/(2r)
                    k1 = 0.02;
                    k2 = 0;
                    break;
                case 'saddle':
                    // Saddle: K < 0
                    k1 = 0.015;
                    k2 = -0.015;
                    break;
                case 'torus':
                    // Torus: varies
                    const R = 80, r = 30;
                    const theta = pos * Math.PI * 2;
                    k1 = 1 / r;
                    k2 = Math.cos(theta) / (R + r * Math.cos(theta));
                    k1 *= 0.02; k2 *= 0.02;  // Scale for display
                    break;
            }
            
            const K = k1 * k2;
            const H = (k1 + k2) / 2;
            
            // Update displays
            document.getElementById('k1').textContent = k1.toFixed(4);
            document.getElementById('k2').textContent = k2.toFixed(4);
            document.getElementById('gaussK').textContent = K.toFixed(6);
            document.getElementById('meanH').textContent = H.toFixed(4);
            
            // Color code K
            const gaussEl = document.getElementById('gaussK');
            if (K > 0.00001) gaussEl.style.color = '#ff6b6b';
            else if (K < -0.00001) gaussEl.style.color = '#6b9fff';
            else gaussEl.style.color = '#88ff88';
            
            // Draw surface wireframe
            const gridSize = 12;
            const scale = 100;
            
            // Simple orthographic projection with rotation
            const cosA = Math.cos(surfaceAngle);
            const sinA = Math.sin(surfaceAngle);
            const cosB = Math.cos(0.5);
            const sinB = Math.sin(0.5);
            
            function project(x, y, z) {
                // Rotate around Y
                const x1 = x * cosA + z * sinA;
                const z1 = -x * sinA + z * cosA;
                // Rotate around X
                const y1 = y * cosB - z1 * sinB;
                const z2 = y * sinB + z1 * cosB;
                
                return [cx + x1, cy - y1, z2];
            }
            
            function getSurfacePoint(u, v) {
                const x = (u - 0.5) * 2 * scale;
                const y = (v - 0.5) * 2 * scale;
                let z = 0;
                
                switch(surfaceType) {
                    case 'sphere':
                        const r = scale * 0.8;
                        const phi = u * Math.PI;
                        const theta = v * Math.PI * 2;
                        return [
                            r * Math.sin(phi) * Math.cos(theta),
                            r * Math.sin(phi) * Math.sin(theta),
                            r * Math.cos(phi)
                        ];
                    case 'cylinder':
                        const rc = scale * 0.5;
                        const tc = v * Math.PI * 2;
                        return [
                            rc * Math.cos(tc),
                            (u - 0.5) * 2 * scale,
                            rc * Math.sin(tc)
                        ];
                    case 'saddle':
                        z = (x*x - y*y) / (scale * 2);
                        return [x, z, y];
                    case 'torus':
                        const R = scale * 0.6, r2 = scale * 0.25;
                        const t1 = u * Math.PI * 2;
                        const t2 = v * Math.PI * 2;
                        return [
                            (R + r2 * Math.cos(t1)) * Math.cos(t2),
                            r2 * Math.sin(t1),
                            (R + r2 * Math.cos(t1)) * Math.sin(t2)
                        ];
                }
            }
            
            // Draw grid
            ctx.strokeStyle = 'rgba(0, 217, 255, 0.3)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= gridSize; i++) {
                const u = i / gridSize;
                
                ctx.beginPath();
                for (let j = 0; j <= gridSize; j++) {
                    const v = j / gridSize;
                    const [x, y, z] = getSurfacePoint(u, v);
                    const [px, py] = project(x, y, z);
                    if (j === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
                
                ctx.beginPath();
                for (let j = 0; j <= gridSize; j++) {
                    const v = j / gridSize;
                    const [x, y, z] = getSurfacePoint(v, u);
                    const [px, py] = project(x, y, z);
                    if (j === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            }
            
            // Draw sample point with principal directions
            const [sx, sy, sz] = getSurfacePoint(sampleU, sampleV);
            const [spx, spy] = project(sx, sy, sz);
            
            ctx.beginPath();
            ctx.arc(spx, spy, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#ffff00';
            ctx.fill();
            
            // Draw principal curvature circles
            const circleR1 = Math.abs(k1) > 0.001 ? Math.min(50, 1 / Math.abs(k1) * 0.5) : 0;
            const circleR2 = Math.abs(k2) > 0.001 ? Math.min(50, 1 / Math.abs(k2) * 0.5) : 0;
            
            if (circleR1 > 5) {
                ctx.beginPath();
                ctx.ellipse(spx, spy - circleR1, circleR1 * 0.8, circleR1 * 0.3, 0, 0, Math.PI * 2);
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            if (circleR2 > 5) {
                ctx.beginPath();
                ctx.ellipse(spx + circleR2, spy, circleR2 * 0.3, circleR2 * 0.8, 0, 0, Math.PI * 2);
                ctx.strokeStyle = k2 < 0 ? '#6b9fff' : '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            surfaceAngle += 0.008;
            requestAnimationFrame(animate3DSurface);
        }

        // ============================================================================
        // Mesh Curvature Visualization
        // ============================================================================
        
        let meshAngle = 0;
        let meshRotating = true;
        
        document.getElementById('meshRotate').addEventListener('click', () => {
            meshRotating = !meshRotating;
        });
        
        function animateMesh() {
            const canvas = document.getElementById('meshCanvas');
            const { ctx, width, height } = setupCanvas(canvas);
            
            const meshType = document.getElementById('meshType').value;
            const meshShow = document.getElementById('meshShow').value;
            const res = parseInt(document.getElementById('meshRes').value);
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            const cx = width / 2, cy = height / 2;
            const scale = Math.min(width, height) * 0.35;
            
            // Generate mesh vertices
            const vertices = [];
            const faces = [];
            const curvatures = [];
            
            for (let i = 0; i <= res; i++) {
                for (let j = 0; j <= res; j++) {
                    const u = (i / res - 0.5) * 2;
                    const v = (j / res - 0.5) * 2;
                    let z = 0;
                    
                    switch(meshType) {
                        case 'wave':
                            z = Math.sin(u * Math.PI * 2) * Math.cos(v * Math.PI * 2) * 0.3;
                            break;
                        case 'bump':
                            z = Math.exp(-(u*u + v*v) * 3) * 0.8;
                            break;
                        case 'saddle':
                            z = (u*u*u - 3*u*v*v) * 0.3;  // Monkey saddle
                            break;
                    }
                    
                    vertices.push([u * scale, z * scale, v * scale]);
                }
            }
            
            // Generate faces and compute curvature at each vertex
            for (let i = 0; i < res; i++) {
                for (let j = 0; j < res; j++) {
                    const idx = i * (res + 1) + j;
                    faces.push([idx, idx + 1, idx + res + 2]);
                    faces.push([idx, idx + res + 2, idx + res + 1]);
                }
            }
            
            // Compute curvature at each vertex using neighbor circles
            for (let i = 0; i <= res; i++) {
                for (let j = 0; j <= res; j++) {
                    const idx = i * (res + 1) + j;
                    const v = vertices[idx];
                    
                    // Get neighbors
                    const neighbors = [];
                    if (i > 0) neighbors.push(vertices[idx - (res + 1)]);
                    if (i < res) neighbors.push(vertices[idx + (res + 1)]);
                    if (j > 0) neighbors.push(vertices[idx - 1]);
                    if (j < res) neighbors.push(vertices[idx + 1]);
                    
                    // Compute discrete Gaussian curvature (angle defect)
                    let angleSum = 0;
                    const n = neighbors.length;
                    for (let k = 0; k < n; k++) {
                        const n1 = neighbors[k];
                        const n2 = neighbors[(k + 1) % n];
                        const v1 = [n1[0] - v[0], n1[1] - v[1], n1[2] - v[2]];
                        const v2 = [n2[0] - v[0], n2[1] - v[1], n2[2] - v[2]];
                        const dot = v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
                        const len1 = Math.sqrt(v1[0]**2 + v1[1]**2 + v1[2]**2);
                        const len2 = Math.sqrt(v2[0]**2 + v2[1]**2 + v2[2]**2);
                        if (len1 > 0 && len2 > 0) {
                            angleSum += Math.acos(Math.max(-1, Math.min(1, dot / (len1 * len2))));
                        }
                    }
                    
                    const K = (i === 0 || i === res || j === 0 || j === res) 
                        ? Math.PI - angleSum  // Boundary
                        : 2 * Math.PI - angleSum;  // Interior
                    
                    // Approximate mean curvature from height differences
                    let H = 0;
                    if (neighbors.length === 4) {
                        const laplacian = neighbors.reduce((sum, n) => sum + n[1], 0) / 4 - v[1];
                        H = laplacian / (scale / res) ** 2;
                    }
                    
                    curvatures.push({ K, H });
                }
            }
            
            // Projection with rotation
            const cosA = Math.cos(meshAngle);
            const sinA = Math.sin(meshAngle);
            const tiltX = 0.4;
            const cosB = Math.cos(tiltX);
            const sinB = Math.sin(tiltX);
            
            function project(v) {
                const x1 = v[0] * cosA + v[2] * sinA;
                const z1 = -v[0] * sinA + v[2] * cosA;
                const y1 = v[1] * cosB - z1 * sinB;
                const z2 = v[1] * sinB + z1 * cosB;
                return [cx + x1, cy - y1, z2];
            }
            
            // Sort faces by depth
            const projectedVerts = vertices.map(project);
            const facesWithDepth = faces.map((f, i) => ({
                f,
                depth: (projectedVerts[f[0]][2] + projectedVerts[f[1]][2] + projectedVerts[f[2]][2]) / 3
            })).sort((a, b) => a.depth - b.depth);
            
            // Draw faces
            for (const { f } of facesWithDepth) {
                const p0 = projectedVerts[f[0]];
                const p1 = projectedVerts[f[1]];
                const p2 = projectedVerts[f[2]];
                
                // Average curvature for face color
                let value;
                if (meshShow === 'gaussian') {
                    value = (curvatures[f[0]].K + curvatures[f[1]].K + curvatures[f[2]].K) / 3;
                } else {
                    value = (curvatures[f[0]].H + curvatures[f[1]].H + curvatures[f[2]].H) / 3;
                }
                
                // Map to color: red (positive) -> green (zero) -> blue (negative)
                const t = Math.max(-1, Math.min(1, value * 5));
                let r, g, b;
                if (t > 0) {
                    r = Math.floor(128 + 127 * t);
                    g = Math.floor(128 * (1 - t));
                    b = Math.floor(128 * (1 - t));
                } else {
                    r = Math.floor(128 * (1 + t));
                    g = Math.floor(128 * (1 + t));
                    b = Math.floor(128 - 127 * t);
                }
                
                ctx.beginPath();
                ctx.moveTo(p0[0], p0[1]);
                ctx.lineTo(p1[0], p1[1]);
                ctx.lineTo(p2[0], p2[1]);
                ctx.closePath();
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
            
            // Draw osculating circles if selected
            if (meshShow === 'circles') {
                // Draw a few sample circles at high curvature points
                const sampleIndices = [
                    Math.floor(res/2) * (res+1) + Math.floor(res/2),
                    Math.floor(res/3) * (res+1) + Math.floor(res/3),
                    Math.floor(2*res/3) * (res+1) + Math.floor(2*res/3)
                ];
                
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                
                for (const idx of sampleIndices) {
                    if (idx < vertices.length) {
                        const p = projectedVerts[idx];
                        const K = Math.abs(curvatures[idx].K);
                        if (K > 0.01) {
                            const r = Math.min(40, 5 / K);
                            ctx.beginPath();
                            ctx.arc(p[0], p[1], r, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                }
                ctx.setLineDash([]);
            }
            
            if (meshRotating) meshAngle += 0.01;
            requestAnimationFrame(animateMesh);
        }

        // Start animations
        animate2DCurve();
        animate3DSurface();
        animateMesh();
    </script>
</body>
</html>
