<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PGA Mesh Processing Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
            padding: 20px;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        .panel {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .panel h2 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #00d9ff;
            border-bottom: 1px solid rgba(0,217,255,0.3);
            padding-bottom: 8px;
        }
        canvas {
            width: 100%;
            height: 300px;
            background: #0a0a12;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .results {
            font-family: 'Fira Code', monospace;
            font-size: 0.85rem;
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 8px;
            line-height: 1.8;
        }
        .results .label {
            color: #888;
        }
        .results .value {
            color: #00ff88;
            font-weight: bold;
        }
        .results .formula {
            color: #ffaa00;
            font-style: italic;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            background: linear-gradient(135deg, #00d9ff, #0088ff);
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 0.85rem;
            transition: transform 0.1s;
        }
        button:hover {
            transform: scale(1.05);
        }
        button:active {
            transform: scale(0.95);
        }
        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .slider-group label {
            font-size: 0.8rem;
            color: #aaa;
            min-width: 100px;
        }
        input[type="range"] {
            flex: 1;
            accent-color: #00d9ff;
        }
        .code-block {
            background: #0d1117;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Fira Code', monospace;
            font-size: 0.75rem;
            overflow-x: auto;
            margin-top: 15px;
            border: 1px solid #30363d;
        }
        .code-block .comment { color: #8b949e; }
        .code-block .keyword { color: #ff7b72; }
        .code-block .string { color: #a5d6ff; }
        .code-block .number { color: #79c0ff; }
        .code-block .function { color: #d2a8ff; }
        .full-width {
            grid-column: 1 / -1;
        }
    </style>
</head>
<body>
    <h1>PGA Mesh Processing</h1>
    <p class="subtitle">Based on "Clean up your Mesh!" - De Keninck, Roelfs, Dorst, Eelbode (2025)</p>

    <div class="container">
        <!-- Box Demo -->
        <div class="panel">
            <h2>üì¶ Unit Box</h2>
            <canvas id="boxCanvas"></canvas>
            <div class="results" id="boxResults">Computing...</div>
        </div>

        <!-- Tetrahedron Demo -->
        <div class="panel">
            <h2>üî∫ Tetrahedron</h2>
            <canvas id="tetraCanvas"></canvas>
            <div class="results" id="tetraResults">Computing...</div>
        </div>

        <!-- Icosahedron Demo -->
        <div class="panel">
            <h2>‚¨° Icosahedron</h2>
            <canvas id="icoCanvas"></canvas>
            <div class="results" id="icoResults">Computing...</div>
        </div>

        <!-- Slicing Demo (Fuel Tank) -->
        <div class="panel">
            <h2>‚úÇÔ∏è Plane Slicing (Fuel Tank Problem)</h2>
            <canvas id="sliceCanvas"></canvas>
            <div class="slider-group">
                <label>Slice Height:</label>
                <input type="range" id="sliceHeight" min="-1" max="1" step="0.01" value="0">
                <span id="sliceHeightVal">0.00</span>
            </div>
            <div class="results" id="sliceResults">Computing...</div>
        </div>

        <!-- Formulas Reference -->
        <div class="panel full-width">
            <h2>üìê PGA Mesh Formulas</h2>
            <div class="code-block">
<span class="comment">// k-Simplex as join of vertices</span>
S‚Çñ = v‚ÇÄ ‚à® v‚ÇÅ ‚à® ... ‚à® v‚Çñ

<span class="comment">// k-Magnitudes (length, area, volume)</span>
<span class="keyword">Edge length</span>    = ‚Äñv‚ÇÄ ‚à® v‚ÇÅ‚Äñ
<span class="keyword">Triangle area</span>  = ¬Ω‚Äñv‚ÇÄ ‚à® v‚ÇÅ ‚à® v‚ÇÇ‚Äñ
<span class="keyword">Tetra volume</span>   = ‚Öô‚Äñv‚ÇÄ ‚à® v‚ÇÅ ‚à® v‚ÇÇ ‚à® v‚ÇÉ‚Äñ

<span class="comment">// Mesh volume from boundary faces (the "mind the gap" technique)</span>
<span class="keyword">Volume</span> = ‚Öô ‚Äñ‚àëF·µ¢‚Äñ<sub>‚àû</sub> = ‚Öô ‚àë(F·µ¢ ‚à® o)

<span class="comment">// Center of mass</span>
<span class="keyword">C<sub>com</sub></span> = <span class="number">1</span>/<span class="number">24V</span> ‚àë(v‚ÇÄ + v‚ÇÅ + v‚ÇÇ + o)(F ‚à® o)

<span class="comment">// Plane side test (for slicing)</span>
p ‚à® v = ax + by + cz + d
            </div>
        </div>
    </div>

    <!-- Inline the GA Mesh library -->
    <script>
    /**
     * Minimal PGA3D Mesh implementation for demo
     */
    const GAMesh = (function() {
        const { sqrt, abs } = Math;
        const EPSILON = 1e-10;

        class PGA3DMesh {
            constructor() {
                this.E0 = 8; this.E1 = 1; this.E2 = 2; this.E3 = 4;
                this.E01 = 9; this.E02 = 10; this.E03 = 12;
                this.E12 = 3; this.E13 = 5; this.E23 = 6;
                this.E012 = 11; this.E013 = 13; this.E023 = 14; this.E123 = 7;
            }

            zero() { return new Float64Array(16); }
            
            point(x, y, z) {
                const mv = this.zero();
                mv[this.E123] = 1;
                mv[this.E023] = -x;
                mv[this.E013] = y;
                mv[this.E012] = -z;
                return mv;
            }

            plane(a, b, c, d) {
                const mv = this.zero();
                mv[this.E1] = a; mv[this.E2] = b; mv[this.E3] = c; mv[this.E0] = d;
                return mv;
            }

            pointCoords(p) {
                const w = p[this.E123] || 1;
                return [-p[this.E023]/w, p[this.E013]/w, -p[this.E012]/w];
            }

            joinPPP(v0, v1, v2) {
                const [x0,y0,z0] = this.pointCoords(v0);
                const [x1,y1,z1] = this.pointCoords(v1);
                const [x2,y2,z2] = this.pointCoords(v2);
                
                const e1x = x1-x0, e1y = y1-y0, e1z = z1-z0;
                const e2x = x2-x0, e2y = y2-y0, e2z = z2-z0;
                
                const nx = e1y*e2z - e1z*e2y;
                const ny = e1z*e2x - e1x*e2z;
                const nz = e1x*e2y - e1y*e2x;
                const d = x0*(y1*z2-z1*y2) + y0*(z1*x2-x1*z2) + z0*(x1*y2-y1*x2);
                
                const plane = this.zero();
                plane[this.E1] = nx; plane[this.E2] = ny; plane[this.E3] = nz;
                plane[this.E0] = -d;
                return plane;
            }

            norm(a) {
                const n1 = a[this.E1]**2 + a[this.E2]**2 + a[this.E3]**2;
                const n2 = a[this.E23]**2 + a[this.E13]**2 + a[this.E12]**2;
                const n3 = a[this.E123]**2;
                return sqrt(n1 + n2 + n3);
            }

            add(a, b) {
                const r = this.zero();
                for (let i = 0; i < 16; i++) r[i] = a[i] + b[i];
                return r;
            }

            planeSide(plane, point) {
                const [x,y,z] = this.pointCoords(point);
                return plane[this.E1]*x + plane[this.E2]*y + plane[this.E3]*z + plane[this.E0];
            }

            edgePlaneIntersection(v0, v1, plane) {
                const d0 = this.planeSide(plane, v0);
                const d1 = this.planeSide(plane, v1);
                if (d0 * d1 > 0) return null;
                if (abs(d0) < EPSILON) return v0.slice();
                if (abs(d1) < EPSILON) return v1.slice();
                const t = d0 / (d0 - d1);
                const [x0,y0,z0] = this.pointCoords(v0);
                const [x1,y1,z1] = this.pointCoords(v1);
                return this.point(x0+t*(x1-x0), y0+t*(y1-y0), z0+t*(z1-z0));
            }
        }

        class Mesh {
            constructor(vertices, faces) {
                this.pga = new PGA3DMesh();
                this.vertices = vertices.map(([x,y,z]) => this.pga.point(x,y,z));
                this.faceIndices = faces;
                this.facePlanes = faces.map(([i0,i1,i2]) => 
                    this.pga.joinPPP(this.vertices[i0], this.vertices[i1], this.vertices[i2]));
                this.rawVertices = vertices;
            }

            volume() {
                let sum = 0;
                for (const F of this.facePlanes) sum += F[this.pga.E0];
                return sum / 6;
            }

            area() {
                let sum = 0;
                for (const F of this.facePlanes) sum += this.pga.norm(F);
                return sum / 2;
            }

            centerOfMass() {
                let cx = 0, cy = 0, cz = 0, totalVol = 0;
                for (let i = 0; i < this.faceIndices.length; i++) {
                    const [i0,i1,i2] = this.faceIndices[i];
                    const [x0,y0,z0] = this.rawVertices[i0];
                    const [x1,y1,z1] = this.rawVertices[i1];
                    const [x2,y2,z2] = this.rawVertices[i2];
                    const vol = this.facePlanes[i][this.pga.E0];
                    cx += (x0+x1+x2) * vol;
                    cy += (y0+y1+y2) * vol;
                    cz += (z0+z1+z2) * vol;
                    totalVol += vol;
                }
                const s = 1 / (4 * totalVol);
                return [cx * s, cy * s, cz * s];
            }

            volumeBelow(plane) {
                let sumD = 0;
                for (let fi = 0; fi < this.faceIndices.length; fi++) {
                    const [i0,i1,i2] = this.faceIndices[fi];
                    const v0 = this.vertices[i0], v1 = this.vertices[i1], v2 = this.vertices[i2];
                    const d0 = this.pga.planeSide(plane, v0);
                    const d1 = this.pga.planeSide(plane, v1);
                    const d2 = this.pga.planeSide(plane, v2);
                    const below = [d0<=0, d1<=0, d2<=0];
                    const countBelow = below[0] + below[1] + below[2];

                    if (countBelow === 3) {
                        sumD += this.facePlanes[fi][this.pga.E0];
                    } else if (countBelow === 0) {
                        continue;
                    } else {
                        const verts = [v0, v1, v2];
                        const ints = [];
                        for (let i = 0; i < 3; i++) {
                            const j = (i+1) % 3;
                            if (below[i] !== below[j]) {
                                const p = this.pga.edgePlaneIntersection(verts[i], verts[j], plane);
                                if (p) ints.push(p);
                            }
                        }
                        if (ints.length === 2) {
                            if (countBelow === 1) {
                                const vB = below[0] ? v0 : (below[1] ? v1 : v2);
                                const F = this.pga.joinPPP(vB, ints[0], ints[1]);
                                sumD += F[this.pga.E0];
                            } else {
                                const vA = !below[0] ? v0 : (!below[1] ? v1 : v2);
                                const Ffull = this.facePlanes[fi][this.pga.E0];
                                const Fabove = this.pga.joinPPP(vA, ints[0], ints[1]);
                                sumD += Ffull - Fabove[this.pga.E0];
                            }
                        }
                    }
                }
                return sumD / 6;
            }
        }

        const Primitives = {
            box(w=1, h=1, d=1) {
                const hw=w/2, hh=h/2, hd=d/2;
                const v = [[-hw,-hh,-hd],[hw,-hh,-hd],[hw,hh,-hd],[-hw,hh,-hd],
                           [-hw,-hh,hd],[hw,-hh,hd],[hw,hh,hd],[-hw,hh,hd]];
                const f = [[0,3,2],[0,2,1],[4,5,6],[4,6,7],[0,1,5],[0,5,4],
                           [2,3,7],[2,7,6],[0,4,7],[0,7,3],[1,2,6],[1,6,5]];
                return new Mesh(v, f);
            },
            tetrahedron(size=1) {
                const s = size / sqrt(2);
                const v = [[s,s,s],[s,-s,-s],[-s,s,-s],[-s,-s,s]];
                const f = [[0,1,2],[0,2,3],[0,3,1],[1,3,2]];
                return new Mesh(v, f);
            },
            icosahedron(r=1) {
                const phi = (1+sqrt(5))/2, a = r/sqrt(1+phi*phi), b = a*phi;
                const v = [[-a,b,0],[a,b,0],[-a,-b,0],[a,-b,0],[0,-a,b],[0,a,b],
                           [0,-a,-b],[0,a,-b],[b,0,-a],[b,0,a],[-b,0,-a],[-b,0,a]];
                const f = [[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],[1,5,9],[5,11,4],
                           [11,10,2],[10,7,6],[7,1,8],[3,9,4],[3,4,2],[3,2,6],[3,6,8],
                           [3,8,9],[4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]];
                return new Mesh(v, f);
            }
        };

        return { PGA3DMesh, Mesh, Primitives };
    })();

    // ========================================================================
    // VISUALIZATION
    // ========================================================================

    function drawMesh(canvas, mesh, options = {}) {
        const ctx = canvas.getContext('2d');
        const W = canvas.width = canvas.offsetWidth * 2;
        const H = canvas.height = canvas.offsetHeight * 2;
        ctx.scale(2, 2);
        
        const { rotX = 0.5, rotY = 0.8, scale = 80, slicePlane = null, highlight = null } = options;
        
        ctx.fillStyle = '#0a0a12';
        ctx.fillRect(0, 0, W/2, H/2);

        const cx = W/4, cy = H/4;
        const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
        const cosY = Math.cos(rotY), sinY = Math.sin(rotY);

        function project(x, y, z) {
            const y1 = y * cosX - z * sinX;
            const z1 = y * sinX + z * cosX;
            const x2 = x * cosY + z1 * sinY;
            const z2 = -x * sinY + z1 * cosY;
            const d = 5;
            const p = d / (d - z2);
            return [cx + x2 * scale * p, cy - y1 * scale * p, z2];
        }

        // Draw edges
        const drawnEdges = new Set();
        for (const [i0, i1, i2] of mesh.faceIndices) {
            const edges = [[i0,i1], [i1,i2], [i2,i0]];
            for (const [a, b] of edges) {
                const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                if (drawnEdges.has(key)) continue;
                drawnEdges.add(key);
                
                const [x0,y0,z0] = mesh.rawVertices[a];
                const [x1,y1,z1] = mesh.rawVertices[b];
                const [px0, py0] = project(x0, y0, z0);
                const [px1, py1] = project(x1, y1, z1);
                
                ctx.beginPath();
                ctx.moveTo(px0, py0);
                ctx.lineTo(px1, py1);
                ctx.strokeStyle = 'rgba(0, 200, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // Draw faces with depth sorting
        const faceData = mesh.faceIndices.map(([i0,i1,i2], fi) => {
            const v = [mesh.rawVertices[i0], mesh.rawVertices[i1], mesh.rawVertices[i2]];
            const cz = (v[0][2] + v[1][2] + v[2][2]) / 3;
            return { fi, v, cz };
        }).sort((a, b) => a.cz - b.cz);

        for (const { fi, v } of faceData) {
            const pts = v.map(([x,y,z]) => project(x, y, z));
            
            // Check if below slice plane
            let color = 'rgba(0, 150, 200, 0.3)';
            if (slicePlane) {
                const pga = mesh.pga;
                const allBelow = v.every(([x,y,z]) => {
                    const p = pga.point(x, y, z);
                    return pga.planeSide(slicePlane, p) <= 0;
                });
                if (allBelow) color = 'rgba(0, 255, 100, 0.4)';
            }
            
            ctx.beginPath();
            ctx.moveTo(pts[0][0], pts[0][1]);
            ctx.lineTo(pts[1][0], pts[1][1]);
            ctx.lineTo(pts[2][0], pts[2][1]);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }

        // Draw slice plane
        if (slicePlane) {
            const h = -slicePlane[8] / slicePlane[2];  // Extract height from plane
            const planeVerts = [[-1.5, h, -1.5], [1.5, h, -1.5], [1.5, h, 1.5], [-1.5, h, 1.5]];
            const pts = planeVerts.map(([x,y,z]) => project(x, y, z));
            ctx.beginPath();
            ctx.moveTo(pts[0][0], pts[0][1]);
            for (let i = 1; i < 4; i++) ctx.lineTo(pts[i][0], pts[i][1]);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 100, 0, 0.2)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 150, 0, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Draw center of mass
        if (highlight) {
            const [px, py] = project(...highlight);
            ctx.beginPath();
            ctx.arc(px, py, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#ff0066';
            ctx.fill();
        }
    }

    // ========================================================================
    // MAIN
    // ========================================================================

    const box = GAMesh.Primitives.box(1, 1, 1);
    const tetra = GAMesh.Primitives.tetrahedron(1.2);
    const ico = GAMesh.Primitives.icosahedron(0.8);

    function formatNum(n, digits = 6) {
        return n.toFixed(digits);
    }

    function updateResults() {
        // Box
        document.getElementById('boxResults').innerHTML = `
            <span class="label">Volume:</span> <span class="value">${formatNum(box.volume())}</span> <span class="formula">(expected: 1.0)</span><br>
            <span class="label">Surface Area:</span> <span class="value">${formatNum(box.area())}</span> <span class="formula">(expected: 6.0)</span><br>
            <span class="label">Center of Mass:</span> <span class="value">[${box.centerOfMass().map(x => formatNum(x, 4)).join(', ')}]</span>
        `;
        drawMesh(document.getElementById('boxCanvas'), box, { highlight: box.centerOfMass() });

        // Tetrahedron
        const tetraExpectedVol = (1.2**3 * sqrt(2)) / 12;
        document.getElementById('tetraResults').innerHTML = `
            <span class="label">Volume:</span> <span class="value">${formatNum(tetra.volume())}</span> <span class="formula">(expected: ${formatNum(tetraExpectedVol)})</span><br>
            <span class="label">Surface Area:</span> <span class="value">${formatNum(tetra.area())}</span><br>
            <span class="label">Center of Mass:</span> <span class="value">[${tetra.centerOfMass().map(x => formatNum(x, 4)).join(', ')}]</span>
        `;
        drawMesh(document.getElementById('tetraCanvas'), tetra, { rotX: 0.6, rotY: 0.5, highlight: tetra.centerOfMass() });

        // Icosahedron
        const phi = (1 + sqrt(5)) / 2;
        const icoExpectedVol = (5/12) * (3 + sqrt(5)) * (0.8**3);
        document.getElementById('icoResults').innerHTML = `
            <span class="label">Volume:</span> <span class="value">${formatNum(ico.volume())}</span> <span class="formula">(expected: ${formatNum(icoExpectedVol)})</span><br>
            <span class="label">Surface Area:</span> <span class="value">${formatNum(ico.area())}</span><br>
            <span class="label">Faces:</span> <span class="value">${ico.faceIndices.length}</span>
        `;
        drawMesh(document.getElementById('icoCanvas'), ico, { rotX: 0.4, rotY: 0.7, scale: 100 });
    }

    // Slice demo
    const sliceBox = GAMesh.Primitives.box(2, 2, 2);
    const sliceHeightInput = document.getElementById('sliceHeight');
    const sliceHeightVal = document.getElementById('sliceHeightVal');

    function updateSlice() {
        const h = parseFloat(sliceHeightInput.value);
        sliceHeightVal.textContent = h.toFixed(2);
        
        const pga = sliceBox.pga;
        const plane = pga.plane(0, 1, 0, -h);  // y = h
        
        const volBelow = sliceBox.volumeBelow(plane);
        const totalVol = sliceBox.volume();
        const pct = (volBelow / totalVol * 100).toFixed(1);
        
        document.getElementById('sliceResults').innerHTML = `
            <span class="label">Slice Height:</span> <span class="value">${h.toFixed(2)}</span><br>
            <span class="label">Volume Below:</span> <span class="value">${formatNum(volBelow)}</span><br>
            <span class="label">Total Volume:</span> <span class="value">${formatNum(totalVol)}</span><br>
            <span class="label">Fill %:</span> <span class="value">${pct}%</span>
        `;
        
        drawMesh(document.getElementById('sliceCanvas'), sliceBox, { 
            rotX: 0.4, rotY: 0.6, scale: 60, slicePlane: plane 
        });
    }

    sliceHeightInput.addEventListener('input', updateSlice);

    // Initial render
    updateResults();
    updateSlice();

    // Animate rotation
    let time = 0;
    function animate() {
        time += 0.01;
        drawMesh(document.getElementById('boxCanvas'), box, { 
            rotX: 0.5, rotY: time, highlight: box.centerOfMass() 
        });
        drawMesh(document.getElementById('tetraCanvas'), tetra, { 
            rotX: 0.6, rotY: time * 0.7, highlight: tetra.centerOfMass() 
        });
        drawMesh(document.getElementById('icoCanvas'), ico, { 
            rotX: 0.4, rotY: time * 0.5, scale: 100 
        });
        requestAnimationFrame(animate);
    }
    animate();
    </script>
</body>
</html>
