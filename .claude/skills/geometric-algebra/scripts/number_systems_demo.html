<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number Systems & Bivector Classification - GA Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a1a 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #e0e0ff;
            padding: 20px;
        }
        h1 {
            text-align: center;
            font-size: 1.6rem;
            margin-bottom: 0.3rem;
            background: linear-gradient(90deg, #ff6b9d, #c44dff, #6b9dff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { 
            text-align: center;
            font-size: 0.9rem; 
            color: #8888aa; 
            margin-bottom: 1rem; 
        }
        
        .tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .tab {
            padding: 8px 20px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .tab:hover { background: rgba(255,255,255,0.1); }
        .tab.active { 
            background: rgba(100,100,200,0.3); 
            border-color: rgba(100,100,200,0.5);
        }
        
        .demo-section {
            display: none;
            max-width: 1000px;
            margin: 0 auto;
        }
        .demo-section.active { display: block; }
        
        .row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .panel {
            background: rgba(20, 20, 40, 0.8);
            border-radius: 10px;
            padding: 12px;
            border: 1px solid rgba(100, 100, 200, 0.2);
        }
        
        .panel-title {
            font-size: 0.95rem;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }
        .elliptic { color: #6be; }
        .parabolic { color: #be6; }
        .hyperbolic { color: #e6b; }
        
        canvas {
            border-radius: 6px;
            background: #0a0a12;
            display: block;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 15px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255,255,255,0.05);
            padding: 6px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .control-group label { 
            font-size: 0.7rem; 
            color: #aac; 
            margin-bottom: 3px; 
        }
        input[type="range"] { width: 100px; accent-color: #c44dff; }
        
        .info-box {
            background: rgba(100,100,200,0.1);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid rgba(100,100,200,0.2);
            font-size: 0.8rem;
            color: #99b;
            line-height: 1.5;
        }
        
        .math { 
            font-family: 'Times New Roman', serif; 
            font-style: italic; 
            color: #c9f; 
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
            margin: 10px 0;
        }
        th, td {
            padding: 5px 8px;
            border: 1px solid rgba(100,100,200,0.3);
            text-align: center;
        }
        th { background: rgba(100,100,200,0.2); }
        
        #status {
            text-align: center;
            font-family: monospace;
            font-size: 0.7rem;
            color: #666;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>Bivector Classification & Number Systems</h1>
    <p class="subtitle">B² determines transformation type: Elliptic (−1) · Parabolic (0) · Hyperbolic (+1)</p>
    
    <div class="tabs">
        <div class="tab active" data-tab="numbers">Three Number Systems</div>
        <div class="tab" data-tab="circles">Circle Classification</div>
        <div class="tab" data-tab="autodiff">Auto-Differentiation</div>
    </div>
    
    <!-- Tab 1: Number Systems -->
    <div class="demo-section active" id="numbers">
        <div class="row">
            <div class="panel">
                <div class="panel-title elliptic">Complex · i² = −1</div>
                <canvas id="complex" width="250" height="250"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title parabolic">Dual · ε² = 0</div>
                <canvas id="dual" width="250" height="250"></canvas>
            </div>
            <div class="panel">
                <div class="panel-title hyperbolic">Hyperbolic · j² = +1</div>
                <canvas id="hyperbolic" width="250" height="250"></canvas>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Parameter θ</label>
                <input type="range" id="theta" min="-3" max="3" step="0.05" value="0">
            </div>
            <div class="control-group">
                <label>Animation</label>
                <input type="range" id="speed" min="0" max="1" step="0.1" value="0.3">
            </div>
        </div>
        
        <div class="info-box">
            <table>
                <tr>
                    <th>Type</th>
                    <th>ι²</th>
                    <th>exp(θι)</th>
                    <th>|z|²</th>
                    <th>Unit Curve</th>
                    <th>Transformation</th>
                </tr>
                <tr>
                    <td class="elliptic">Complex</td>
                    <td class="math">−1</td>
                    <td class="math">cos θ + i sin θ</td>
                    <td class="math">a² + b²</td>
                    <td>Circle</td>
                    <td>Rotation</td>
                </tr>
                <tr>
                    <td class="parabolic">Dual</td>
                    <td class="math">0</td>
                    <td class="math">1 + εθ</td>
                    <td class="math">a²</td>
                    <td>Vertical lines</td>
                    <td>Shear</td>
                </tr>
                <tr>
                    <td class="hyperbolic">Hyperbolic</td>
                    <td class="math">+1</td>
                    <td class="math">cosh θ + j sinh θ</td>
                    <td class="math">a² − b²</td>
                    <td>Hyperbola</td>
                    <td>Squeeze</td>
                </tr>
            </table>
        </div>
    </div>
    
    <!-- Tab 2: Circle Classification -->
    <div class="demo-section" id="circles">
        <div class="row">
            <div class="panel" style="flex: 1; max-width: 500px;">
                <div class="panel-title">Circle Pair → Transformation Type</div>
                <canvas id="circleCanvas" width="450" height="350"></canvas>
            </div>
            <div class="panel" style="min-width: 280px;">
                <div class="panel-title">Classification</div>
                <div id="circleInfo" style="font-size: 0.8rem; padding: 10px;">
                    Drag circles to change their relationship
                </div>
                <div class="info-box" style="margin-top: 10px;">
                    <strong>Discriminant:</strong> <span class="math">Δ = (C₁·C₂)² − C₁²C₂²</span>
                    <br><br>
                    <span class="elliptic">Δ &lt; 0</span> → Intersecting → Elliptic<br>
                    <span class="parabolic">Δ = 0</span> → Tangent → Parabolic<br>
                    <span class="hyperbolic">Δ &gt; 0</span> → Nested/Disjoint → Hyperbolic
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Circle 2 Distance</label>
                <input type="range" id="c2dist" min="0" max="3" step="0.05" value="1.5">
            </div>
            <div class="control-group">
                <label>Circle 2 Radius</label>
                <input type="range" id="c2radius" min="0.3" max="2" step="0.05" value="0.8">
            </div>
        </div>
    </div>
    
    <!-- Tab 3: Auto-Differentiation -->
    <div class="demo-section" id="autodiff">
        <div class="row">
            <div class="panel" style="flex: 1; max-width: 500px;">
                <div class="panel-title parabolic">Dual Numbers → Automatic Derivatives</div>
                <canvas id="autodiffCanvas" width="450" height="300"></canvas>
            </div>
            <div class="panel" style="min-width: 300px;">
                <div class="panel-title">The Magic of ε² = 0</div>
                <div class="info-box">
                    <p>Because <span class="math">ε² = 0</span>, evaluating <span class="math">f(a + ε)</span> gives:</p>
                    <div style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; margin: 8px 0; text-align: center;">
                        <span class="math">f(a + ε) = f(a) + f′(a)·ε</span>
                    </div>
                    <p>The dual part automatically carries the derivative!</p>
                    <br>
                    <p><strong>Example:</strong> <span class="math">f(x) = x²</span></p>
                    <p><span class="math">(a + ε)² = a² + 2aε + ε² = a² + 2aε</span></p>
                    <p>So <span class="math">f′(a) = 2a</span> ✓</p>
                </div>
                <div id="autodiffInfo" style="font-size: 0.8rem; padding: 10px; margin-top: 10px;"></div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>x value</label>
                <input type="range" id="xval" min="-2" max="2" step="0.05" value="1">
            </div>
            <div class="control-group">
                <label>Function</label>
                <select id="func" style="background: rgba(255,255,255,0.1); color: #e0e0ff; border: 1px solid rgba(255,255,255,0.2); padding: 4px; border-radius: 4px;">
                    <option value="x2">x²</option>
                    <option value="x3">x³</option>
                    <option value="sin">sin(x)</option>
                    <option value="exp">eˣ</option>
                    <option value="poly">(x²+1)·x</option>
                </select>
            </div>
        </div>
    </div>
    
    <div id="status"></div>

    <script>
    // ============================================================================
    // NUMBER SYSTEMS (inline from ga_number_systems.js)
    // ============================================================================
    
    const EPSILON = 1e-10;
    const { sqrt, sin, cos, sinh, cosh, abs, PI } = Math;
    
    class Complex {
        constructor(a = 0, b = 0) { this.a = a; this.b = b; }
        add(z) { return new Complex(this.a + z.a, this.b + z.b); }
        mul(z) { return new Complex(this.a*z.a - this.b*z.b, this.a*z.b + this.b*z.a); }
        scale(s) { return new Complex(this.a * s, this.b * s); }
        normSq() { return this.a*this.a + this.b*this.b; }
        static exp(t) { return new Complex(cos(t), sin(t)); }
        static unitCurve(t) { return new Complex(cos(t), sin(t)); }
    }
    
    class Dual {
        constructor(a = 0, b = 0) { this.a = a; this.b = b; }
        add(z) { return new Dual(this.a + z.a, this.b + z.b); }
        mul(z) { return new Dual(this.a*z.a, this.a*z.b + this.b*z.a); }
        scale(s) { return new Dual(this.a * s, this.b * s); }
        normSq() { return this.a*this.a; }
        static exp(t) { return new Dual(1, t); }
        static unitCurve(t) { return new Dual(1, t); }
    }
    
    class Hyperbolic {
        constructor(a = 0, b = 0) { this.a = a; this.b = b; }
        add(z) { return new Hyperbolic(this.a + z.a, this.b + z.b); }
        mul(z) { return new Hyperbolic(this.a*z.a + this.b*z.b, this.a*z.b + this.b*z.a); }
        scale(s) { return new Hyperbolic(this.a * s, this.b * s); }
        normSq() { return this.a*this.a - this.b*this.b; }
        static exp(t) { return new Hyperbolic(cosh(t), sinh(t)); }
        static unitCurve(t) { return new Hyperbolic(cosh(t), sinh(t)); }
    }
    
    // ============================================================================
    // TAB SWITCHING
    // ============================================================================
    
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.demo-section').forEach(s => s.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById(tab.dataset.tab).classList.add('active');
        });
    });
    
    // ============================================================================
    // NUMBER SYSTEMS VISUALIZATION
    // ============================================================================
    
    const numCanvases = {
        complex: document.getElementById('complex'),
        dual: document.getElementById('dual'),
        hyperbolic: document.getElementById('hyperbolic')
    };
    
    const numCtx = {
        complex: numCanvases.complex.getContext('2d'),
        dual: numCanvases.dual.getContext('2d'),
        hyperbolic: numCanvases.hyperbolic.getContext('2d')
    };
    
    const W = 250, H = 250;
    const cx = W/2, cy = H/2;
    const scale = 50;
    
    const params = { theta: 0, speed: 0.3, c2dist: 1.5, c2radius: 0.8, xval: 1, func: 'x2' };
    
    document.getElementById('theta').oninput = e => params.theta = +e.target.value;
    document.getElementById('speed').oninput = e => params.speed = +e.target.value;
    document.getElementById('c2dist').oninput = e => params.c2dist = +e.target.value;
    document.getElementById('c2radius').oninput = e => params.c2radius = +e.target.value;
    document.getElementById('xval').oninput = e => params.xval = +e.target.value;
    document.getElementById('func').onchange = e => params.func = e.target.value;
    
    const colors = {
        complex: { main: '#6be', light: 'rgba(102,187,238,0.3)', unit: '#4ad' },
        dual: { main: '#be6', light: 'rgba(187,238,102,0.3)', unit: '#ad4' },
        hyperbolic: { main: '#e6b', light: 'rgba(238,102,187,0.3)', unit: '#d4a' }
    };
    
    function drawNumberSystem(ctx, Cls, color, theta) {
        ctx.fillStyle = '#0a0a12';
        ctx.fillRect(0, 0, W, H);
        
        // Grid
        ctx.strokeStyle = 'rgba(50,50,80,0.3)';
        ctx.lineWidth = 0.5;
        for (let i = -4; i <= 4; i++) {
            ctx.beginPath(); ctx.moveTo(cx + i*scale, 0); ctx.lineTo(cx + i*scale, H); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, cy + i*scale); ctx.lineTo(W, cy + i*scale); ctx.stroke();
        }
        
        // Unit curve
        ctx.beginPath();
        ctx.strokeStyle = color.unit;
        ctx.lineWidth = 2;
        
        if (Cls === Complex) {
            ctx.arc(cx, cy, scale, 0, 2*PI);
        } else if (Cls === Dual) {
            ctx.moveTo(cx + scale, 0); ctx.lineTo(cx + scale, H);
            ctx.moveTo(cx - scale, 0); ctx.lineTo(cx - scale, H);
        } else {
            // Hyperbola
            for (let i = -25; i <= 25; i++) {
                const t = i * 0.12;
                const z = Cls.unitCurve(t);
                const x = cx + z.a * scale, y = cy - z.b * scale;
                if (i === -25) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.beginPath();
            for (let i = -25; i <= 25; i++) {
                const t = i * 0.12;
                const z = Cls.unitCurve(t);
                const x = cx - z.a * scale, y = cy - z.b * scale;
                if (i === -25) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            // Null cone for hyperbolic
            ctx.stroke();
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255,100,100,0.3)';
            ctx.moveTo(0, H); ctx.lineTo(W, 0);
            ctx.moveTo(0, 0); ctx.lineTo(W, H);
        }
        ctx.stroke();
        
        // Grid points transformed
        const expT = Cls.exp(theta);
        const gridPts = [];
        for (let i = -2; i <= 2; i++) {
            for (let j = -2; j <= 2; j++) {
                if (i === 0 && j === 0) continue;
                gridPts.push(new Cls(i * 0.6, j * 0.6));
            }
        }
        
        gridPts.forEach(p => {
            // Original (faint)
            ctx.beginPath();
            ctx.arc(cx + p.a * scale, cy - p.b * scale, 3, 0, 2*PI);
            ctx.fillStyle = color.light;
            ctx.fill();
            
            // Transformed
            const tp = expT.mul(p);
            if (abs(tp.a) < 4 && abs(tp.b) < 4) {
                ctx.beginPath();
                ctx.moveTo(cx + p.a * scale, cy - p.b * scale);
                ctx.lineTo(cx + tp.a * scale, cy - tp.b * scale);
                ctx.strokeStyle = color.light;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(cx + tp.a * scale, cy - tp.b * scale, 4, 0, 2*PI);
                ctx.fillStyle = color.main;
                ctx.fill();
            }
        });
        
        // exp(θι) point
        ctx.beginPath();
        ctx.arc(cx + expT.a * scale, cy - expT.b * scale, 6, 0, 2*PI);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.strokeStyle = color.main;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + expT.a * scale, cy - expT.b * scale);
        ctx.stroke();
        
        // Label
        ctx.fillStyle = '#888';
        ctx.font = '10px monospace';
        ctx.fillText(`exp(${theta.toFixed(2)}ι) = (${expT.a.toFixed(2)}, ${expT.b.toFixed(2)})`, 5, 15);
    }
    
    // ============================================================================
    // CIRCLE CLASSIFICATION
    // ============================================================================
    
    const circleCanvas = document.getElementById('circleCanvas');
    const circleCtx = circleCanvas.getContext('2d');
    const CW = 450, CH = 350;
    const ccx = CW/2, ccy = CH/2;
    const cscale = 70;
    
    function classifyCircles(x1, y1, r1, x2, y2, r2) {
        const d = sqrt((x2-x1)**2 + (y2-y1)**2);
        
        if (d < abs(r1 - r2) - 0.01) return { type: 'hyperbolic', desc: 'nested' };
        if (abs(d - abs(r1 - r2)) < 0.05) return { type: 'parabolic', desc: 'internally tangent' };
        if (d < r1 + r2 - 0.01) return { type: 'elliptic', desc: 'intersecting' };
        if (abs(d - (r1 + r2)) < 0.05) return { type: 'parabolic', desc: 'externally tangent' };
        return { type: 'hyperbolic', desc: 'disjoint' };
    }
    
    function drawCircles() {
        const ctx = circleCtx;
        ctx.fillStyle = '#0a0a12';
        ctx.fillRect(0, 0, CW, CH);
        
        // Grid
        ctx.strokeStyle = 'rgba(50,50,80,0.3)';
        ctx.lineWidth = 0.5;
        for (let i = -5; i <= 5; i++) {
            ctx.beginPath(); ctx.moveTo(ccx + i*cscale, 0); ctx.lineTo(ccx + i*cscale, CH); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, ccy + i*cscale); ctx.lineTo(CW, ccy + i*cscale); ctx.stroke();
        }
        
        const c1 = { x: 0, y: 0, r: 1 };
        const c2 = { x: params.c2dist, y: 0, r: params.c2radius };
        
        const result = classifyCircles(c1.x, c1.y, c1.r, c2.x, c2.y, c2.r);
        
        const typeColors = {
            elliptic: '#6be',
            parabolic: '#be6',
            hyperbolic: '#e6b'
        };
        
        // Circle 1
        ctx.beginPath();
        ctx.arc(ccx + c1.x * cscale, ccy - c1.y * cscale, c1.r * cscale, 0, 2*PI);
        ctx.strokeStyle = '#88a';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Circle 2
        ctx.beginPath();
        ctx.arc(ccx + c2.x * cscale, ccy - c2.y * cscale, c2.r * cscale, 0, 2*PI);
        ctx.strokeStyle = typeColors[result.type];
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Centers
        ctx.beginPath();
        ctx.arc(ccx + c1.x * cscale, ccy - c1.y * cscale, 4, 0, 2*PI);
        ctx.fillStyle = '#88a';
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(ccx + c2.x * cscale, ccy - c2.y * cscale, 4, 0, 2*PI);
        ctx.fillStyle = typeColors[result.type];
        ctx.fill();
        
        // Update info
        document.getElementById('circleInfo').innerHTML = `
            <div style="color: ${typeColors[result.type]}; font-size: 1.1rem; font-weight: bold; margin-bottom: 8px;">
                ${result.type.toUpperCase()}
            </div>
            <div>Configuration: <strong>${result.desc}</strong></div>
            <div>Distance: ${params.c2dist.toFixed(2)}</div>
            <div>Sum of radii: ${(c1.r + c2.r).toFixed(2)}</div>
            <div>Diff of radii: ${abs(c1.r - c2.r).toFixed(2)}</div>
        `;
    }
    
    // ============================================================================
    // AUTO-DIFFERENTIATION
    // ============================================================================
    
    const adCanvas = document.getElementById('autodiffCanvas');
    const adCtx = adCanvas.getContext('2d');
    const AW = 450, AH = 300;
    const acx = AW/2, acy = AH/2;
    const ascale = 50;
    
    // Dual number functions for auto-diff
    function dualFunc(x, funcName) {
        const d = new Dual(x, 1);  // x + ε
        switch (funcName) {
            case 'x2': return d.mul(d);
            case 'x3': return d.mul(d).mul(d);
            case 'sin': return new Dual(sin(d.a), cos(d.a) * d.b);
            case 'exp': return new Dual(Math.exp(d.a), Math.exp(d.a) * d.b);
            case 'poly': return d.mul(d).add(new Dual(1, 0)).mul(d);
        }
    }
    
    function realFunc(x, funcName) {
        switch (funcName) {
            case 'x2': return x * x;
            case 'x3': return x * x * x;
            case 'sin': return sin(x);
            case 'exp': return Math.exp(x);
            case 'poly': return (x*x + 1) * x;
        }
    }
    
    function drawAutodiff() {
        const ctx = adCtx;
        ctx.fillStyle = '#0a0a12';
        ctx.fillRect(0, 0, AW, AH);
        
        // Grid
        ctx.strokeStyle = 'rgba(50,50,80,0.3)';
        ctx.lineWidth = 0.5;
        for (let i = -6; i <= 6; i++) {
            ctx.beginPath(); ctx.moveTo(acx + i*ascale, 0); ctx.lineTo(acx + i*ascale, AH); ctx.stroke();
        }
        for (let i = -4; i <= 4; i++) {
            ctx.beginPath(); ctx.moveTo(0, acy + i*ascale); ctx.lineTo(AW, acy + i*ascale); ctx.stroke();
        }
        
        // Axes
        ctx.strokeStyle = 'rgba(100,100,150,0.6)';
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0, acy); ctx.lineTo(AW, acy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(acx, 0); ctx.lineTo(acx, AH); ctx.stroke();
        
        // Draw function
        ctx.beginPath();
        ctx.strokeStyle = '#6be';
        ctx.lineWidth = 2;
        for (let px = 0; px < AW; px++) {
            const x = (px - acx) / ascale;
            const y = realFunc(x, params.func);
            const py = acy - y * ascale;
            if (px === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.stroke();
        
        // Compute at point
        const x = params.xval;
        const result = dualFunc(x, params.func);
        const fx = result.a;
        const dfx = result.b;
        
        // Tangent line
        ctx.beginPath();
        ctx.strokeStyle = '#be6';
        ctx.lineWidth = 2;
        const x1 = x - 2, x2 = x + 2;
        const y1 = fx + dfx * (x1 - x);
        const y2 = fx + dfx * (x2 - x);
        ctx.moveTo(acx + x1 * ascale, acy - y1 * ascale);
        ctx.lineTo(acx + x2 * ascale, acy - y2 * ascale);
        ctx.stroke();
        
        // Point
        ctx.beginPath();
        ctx.arc(acx + x * ascale, acy - fx * ascale, 6, 0, 2*PI);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.strokeStyle = '#be6';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Info
        document.getElementById('autodiffInfo').innerHTML = `
            <div><strong>At x = ${x.toFixed(2)}:</strong></div>
            <div style="color: #6be;">f(x) = ${fx.toFixed(4)}</div>
            <div style="color: #be6;">f′(x) = ${dfx.toFixed(4)}</div>
            <br>
            <div style="font-size: 0.75rem; color: #888;">
                Computed via: f(${x.toFixed(2)} + ε) = ${fx.toFixed(2)} + ${dfx.toFixed(2)}ε
            </div>
        `;
    }
    
    // ============================================================================
    // ANIMATION
    // ============================================================================
    
    let time = 0;
    
    function animate() {
        time += 0.016 * params.speed;
        const theta = params.speed > 0 ? sin(time) * 2 : params.theta;
        
        drawNumberSystem(numCtx.complex, Complex, colors.complex, theta);
        drawNumberSystem(numCtx.dual, Dual, colors.dual, theta);
        drawNumberSystem(numCtx.hyperbolic, Hyperbolic, colors.hyperbolic, theta);
        
        drawCircles();
        drawAutodiff();
        
        document.getElementById('status').textContent = `θ = ${theta.toFixed(2)}`;
        
        requestAnimationFrame(animate);
    }
    
    animate();
    </script>
</body>
</html>
