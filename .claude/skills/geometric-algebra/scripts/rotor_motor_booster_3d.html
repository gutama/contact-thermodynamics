<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rotor vs Motor vs Booster - 3D Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0a15; color: #eee; overflow-x: hidden; }
        .header { text-align: center; padding: 20px; background: linear-gradient(180deg, #1a1a2e 0%, #0a0a15 100%); }
        h1 { font-size: 2.2rem; color: #e94560; margin-bottom: 10px; }
        .subtitle { color: #888; font-size: 1.1rem; }
        .main-container { display: flex; flex-direction: column; min-height: calc(100vh - 100px); }
        .visualization-row { display: flex; flex: 1; min-height: 500px; }
        .viz-panel { flex: 1; position: relative; border-right: 1px solid #333; }
        .viz-panel:last-child { border-right: none; }
        .panel-label { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 8px 20px; border-radius: 20px; font-weight: bold; z-index: 10; border: 2px solid; }
        .panel-label.rotor { border-color: #7fdbff; color: #7fdbff; }
        .panel-label.motor { border-color: #2ecc40; color: #2ecc40; }
        .panel-label.booster { border-color: #e94560; color: #e94560; }
        .panel-info { position: absolute; bottom: 10px; left: 10px; right: 10px; background: rgba(0,0,0,0.85); padding: 12px; border-radius: 8px; font-size: 0.85rem; z-index: 10; }
        .panel-info .formula { font-family: 'Times New Roman', serif; font-style: italic; color: #98d8c8; margin: 5px 0; }
        .panel-info .property { color: #888; font-size: 0.8rem; }
        .controls-container { background: #16213e; padding: 20px; display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; }
        .control-group { background: #1a1a2e; padding: 15px; border-radius: 10px; min-width: 200px; }
        .control-group h3 { font-size: 0.95rem; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #333; }
        .control-group h3.rotor { color: #7fdbff; }
        .control-group h3.motor { color: #2ecc40; }
        .control-group h3.booster { color: #e94560; }
        .control-group h3.mesh { color: #ffdc00; }
        .slider-row { margin: 10px 0; }
        .slider-row label { display: flex; justify-content: space-between; font-size: 0.85rem; color: #aaa; margin-bottom: 4px; }
        .slider-row label span { color: #fff; font-family: monospace; }
        input[type="range"] { width: 100%; accent-color: #e94560; }
        .btn-row { display: flex; gap: 8px; margin-top: 15px; }
        button { flex: 1; padding: 10px 15px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85rem; }
        button.primary { background: #e94560; color: white; }
        button.primary:hover { background: #ff6b7a; }
        button.secondary { background: #333; color: #ccc; }
        button.secondary:hover { background: #444; }
        select { width: 100%; padding: 8px; background: #0a0a15; border: 1px solid #333; border-radius: 6px; color: #eee; margin-top: 5px; }
        .comparison-table { width: 100%; max-width: 900px; margin: 20px auto; border-collapse: collapse; font-size: 0.9rem; }
        .comparison-table th, .comparison-table td { padding: 12px; border: 1px solid #333; text-align: center; }
        .comparison-table th { background: #1a1a2e; color: #e94560; }
        .comparison-table .check { color: #2ecc40; }
        .comparison-table .cross { color: #e94560; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üåÄ Rotor vs Motor vs Booster</h1>
        <p class="subtitle">Compare transformations ‚Äî Booster uses CGA via ga_versor_extensions.js</p>
    </div>

    <div class="main-container">
        <div class="visualization-row">
            <div class="viz-panel" id="rotorPanel">
                <div class="panel-label rotor">ROTOR</div>
                <div class="panel-info">
                    <div class="formula">R = cos(Œ∏/2) - sin(Œ∏/2)¬∑B</div>
                    <div class="property">Generator: Bivector | Preserves distances ‚úì</div>
                </div>
            </div>
            <div class="viz-panel" id="motorPanel">
                <div class="panel-label motor">MOTOR</div>
                <div class="panel-info">
                    <div class="formula">M = T ¬∑ R (Translator √ó Rotor)</div>
                    <div class="property">Generator: Dual Line | Pitch: <span id="motorPitchVal">‚àû</span></div>
                </div>
            </div>
            <div class="viz-panel" id="boosterPanel">
                <div class="panel-label booster">BOOSTER (CGA)</div>
                <div class="panel-info">
                    <div class="formula">B = cga.Gen.bst(P‚ÇÅ‚àßP‚ÇÇ)</div>
                    <div class="property">Generator: Point Pair | Creates CURVATURE</div>
                </div>
            </div>
        </div>

        <div class="controls-container">
            <div class="control-group">
                <h3 class="rotor">üîÑ Rotor</h3>
                <div class="slider-row"><label>Angle <span id="rotorAngleVal">45¬∞</span></label><input type="range" id="rotorAngle" min="-180" max="180" value="45"></div>
                <div class="slider-row"><label>Axis X <span id="rotorAxisXVal">0.0</span></label><input type="range" id="rotorAxisX" min="-1" max="1" step="0.1" value="0"></div>
                <div class="slider-row"><label>Axis Y <span id="rotorAxisYVal">0.0</span></label><input type="range" id="rotorAxisY" min="-1" max="1" step="0.1" value="0"></div>
                <div class="slider-row"><label>Axis Z <span id="rotorAxisZVal">1.0</span></label><input type="range" id="rotorAxisZ" min="-1" max="1" step="0.1" value="1"></div>
            </div>

            <div class="control-group">
                <h3 class="motor">‚öôÔ∏è Motor</h3>
                <div class="slider-row"><label>Rotation <span id="motorRotVal">30¬∞</span></label><input type="range" id="motorRot" min="-180" max="180" value="30"></div>
                <div class="slider-row"><label>Translation <span id="motorTransVal">0.5</span></label><input type="range" id="motorTrans" min="-2" max="2" step="0.1" value="0.5"></div>
            </div>

            <div class="control-group">
                <h3 class="booster">üåä Booster</h3>
                <div class="slider-row"><label>Amount <span id="boostAmountVal">0.30</span></label><input type="range" id="boostAmount" min="-1" max="1" step="0.02" value="0.3"></div>
                <div class="slider-row"><label>Separation <span id="boostSepVal">2.0</span></label><input type="range" id="boostSep" min="0.5" max="4" step="0.1" value="2"></div>
                <div class="slider-row"><label>Axis</label><select id="boostAxis"><option value="y" selected>Y axis</option><option value="x">X axis</option><option value="z">Z axis</option></select></div>
            </div>

            <div class="control-group">
                <h3 class="mesh">üìê Mesh</h3>
                <div class="slider-row"><label>Type</label><select id="meshType"><option value="plane" selected>Plane</option><option value="box">Box</option><option value="sphere">Sphere</option><option value="torus">Torus</option></select></div>
                <div class="slider-row"><label>Resolution <span id="gridResVal">12</span></label><input type="range" id="gridRes" min="4" max="24" value="12"></div>
                <div class="btn-row"><button class="primary" id="animateBtn">‚ñ∂ Animate</button><button class="secondary" id="resetBtn">Reset</button></div>
            </div>
        </div>

        <table class="comparison-table">
            <tr><th>Property</th><th style="color:#7fdbff">Rotor</th><th style="color:#2ecc40">Motor</th><th style="color:#e94560">Booster</th></tr>
            <tr><td>Preserves Distances</td><td class="check">‚úì</td><td class="check">‚úì</td><td class="cross">‚úó</td></tr>
            <tr><td>Preserves Angles</td><td class="check">‚úì</td><td class="check">‚úì</td><td class="check">‚úì (conformal)</td></tr>
            <tr><td>Creates Curvature</td><td class="cross">‚úó</td><td class="cross">‚úó</td><td class="check">‚úì</td></tr>
            <tr><td>Generator</td><td>Bivector</td><td>Dual Line</td><td>Point Pair</td></tr>
            <tr><td>Implementation</td><td>Quaternion</td><td>Screw</td><td>CGA cga.Gen.bst()</td></tr>
        </table>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Load GA skill scripts -->
    <script src="ga_vanilla.js"></script>
    <script src="ga_versor_extensions.js"></script>

    <script>
    // ============================================================================
    // Initialize CGA from skill
    // ============================================================================
    const cga = new VersorGA.CGA3DVersor();
    
    const EPSILON = 1e-10;
    let scenes = {}, cameras = {}, renderers = {}, meshes = {};
    let originalVertices = [];
    let animating = false, animationTime = 0;
    
    // ============================================================================
    // Euclidean helpers for Rotor/Motor (standard transforms)
    // ============================================================================
    
    function rotatePoint(p, axis, angle) {
        const len = Math.sqrt(axis[0]**2 + axis[1]**2 + axis[2]**2);
        if (len < EPSILON) return p;
        const ax = axis[0]/len, ay = axis[1]/len, az = axis[2]/len;
        const half = angle / 2;
        const qw = Math.cos(half), qs = Math.sin(half);
        const qx = qs * ax, qy = qs * ay, qz = qs * az;
        const tx = 2 * (qy * p[2] - qz * p[1]);
        const ty = 2 * (qz * p[0] - qx * p[2]);
        const tz = 2 * (qx * p[1] - qy * p[0]);
        return [
            p[0] + qw * tx + qy * tz - qz * ty,
            p[1] + qw * ty + qz * tx - qx * tz,
            p[2] + qw * tz + qx * ty - qy * tx
        ];
    }
    
    function motorTransform(p, rotAngle, transZ) {
        const rotated = rotatePoint(p, [0, 0, 1], rotAngle);
        return [rotated[0], rotated[1], rotated[2] + transZ];
    }
    
    // ============================================================================
    // CGA Booster - Uses actual skill API
    // ============================================================================
    
    function boosterTransform(p, p1Coords, p2Coords, amount) {
        if (Math.abs(amount) < EPSILON) return p;
        
        // Create CGA points
        const P1 = cga.point(p1Coords[0], p1Coords[1], p1Coords[2]);
        const P2 = cga.point(p2Coords[0], p2Coords[1], p2Coords[2]);
        
        // Create point pair via wedge product
        const pp = P1.wedge(P2);
        
        // Scale point pair by amount
        const scaledPP = pp.scale(amount);
        
        // Create booster using Gen.bst()
        const booster = cga.Gen.bst(scaledPP);
        
        // Transform point using spin (sandwich product)
        const pt = cga.point(p[0], p[1], p[2]);
        const transformed = cga.spin(pt, booster);
        
        // Extract coordinates
        return cga.pointCoords(transformed);
    }
    
    // ============================================================================
    // THREE.JS Setup
    // ============================================================================
    
    function initPanel(panelId) {
        const container = document.getElementById(panelId);
        const width = container.clientWidth, height = container.clientHeight;
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a15);
        
        const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 100);
        camera.position.set(4, 3, 4);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);
        
        scene.add(new THREE.AmbientLight(0x404040, 0.5));
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(5, 5, 5);
        scene.add(light);
        scene.add(new THREE.GridHelper(6, 12, 0x333333, 0x222222));
        scene.add(new THREE.AxesHelper(1.5));
        
        scenes[panelId] = scene;
        cameras[panelId] = camera;
        renderers[panelId] = renderer;
    }
    
    function createMeshGeometry(type, res) {
        const geos = {
            plane: () => new THREE.PlaneGeometry(3, 3, res, res),
            box: () => new THREE.BoxGeometry(2, 2, 2, res/2, res/2, res/2),
            sphere: () => new THREE.SphereGeometry(1.2, res, res),
            torus: () => new THREE.TorusGeometry(1, 0.4, res/2, res)
        };
        return (geos[type] || geos.plane)();
    }
    
    function createMeshes() {
        const meshType = document.getElementById('meshType').value;
        const resolution = parseInt(document.getElementById('gridRes').value);
        
        for (const key in meshes) {
            const panelKey = key + 'Panel';
            if (meshes[key].transformed) scenes[panelKey].remove(meshes[key].transformed);
            if (meshes[key].wireframe) scenes[panelKey].remove(meshes[key].wireframe);
            if (meshes[key].generator) scenes[panelKey].remove(meshes[key].generator);
        }
        
        const geometry = createMeshGeometry(meshType, resolution);
        
        originalVertices = [];
        const positions = geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
            let x = positions[i], y = positions[i + 1], z = positions[i + 2];
            if (meshType === 'plane') { const t = y; y = z; z = -t; }
            originalVertices.push([x, y, z]);
        }
        
        const configs = [
            { panel: 'rotorPanel', color: 0x7fdbff, key: 'rotor' },
            { panel: 'motorPanel', color: 0x2ecc40, key: 'motor' },
            { panel: 'boosterPanel', color: 0xe94560, key: 'booster' }
        ];
        
        for (const config of configs) {
            const scene = scenes[config.panel];
            
            const wireGeo = geometry.clone();
            if (meshType === 'plane') wireGeo.rotateX(-Math.PI / 2);
            const wireframe = new THREE.Mesh(wireGeo, new THREE.MeshBasicMaterial({ color: 0x444444, wireframe: true, transparent: true, opacity: 0.3 }));
            scene.add(wireframe);
            
            const transGeo = geometry.clone();
            if (meshType === 'plane') transGeo.rotateX(-Math.PI / 2);
            const transformed = new THREE.Mesh(transGeo, new THREE.MeshPhongMaterial({ color: config.color, wireframe: true, transparent: true, opacity: 0.9 }));
            scene.add(transformed);
            
            const generator = new THREE.Group();
            scene.add(generator);
            
            meshes[config.key] = { wireframe, transformed, generator };
        }
        
        updateTransformations();
    }
    
    function updateTransformations() {
        const rotorAngle = parseFloat(document.getElementById('rotorAngle').value) * Math.PI / 180;
        const rotorAxis = [
            parseFloat(document.getElementById('rotorAxisX').value),
            parseFloat(document.getElementById('rotorAxisY').value),
            parseFloat(document.getElementById('rotorAxisZ').value)
        ];
        
        const motorRot = parseFloat(document.getElementById('motorRot').value) * Math.PI / 180;
        const motorTrans = parseFloat(document.getElementById('motorTrans').value);
        
        const boostAmount = parseFloat(document.getElementById('boostAmount').value);
        const boostSep = parseFloat(document.getElementById('boostSep').value);
        const boostAxis = document.getElementById('boostAxis').value;
        
        document.getElementById('motorPitchVal').textContent = Math.abs(motorRot) > 0.01 ? (motorTrans / motorRot).toFixed(2) : '‚àû';
        
        let p1, p2;
        switch (boostAxis) {
            case 'x': p1 = [-boostSep/2, 0, 0]; p2 = [boostSep/2, 0, 0]; break;
            case 'y': p1 = [0, -boostSep/2, 0]; p2 = [0, boostSep/2, 0]; break;
            case 'z': p1 = [0, 0, -boostSep/2]; p2 = [0, 0, boostSep/2]; break;
        }
        
        const rotorVerts = [], motorVerts = [], boosterVerts = [];
        
        for (const v of originalVertices) {
            // Rotor: standard rotation
            rotorVerts.push(rotatePoint(v, rotorAxis, rotorAngle));
            
            // Motor: rotation + translation
            motorVerts.push(motorTransform(v, motorRot, motorTrans));
            
            // Booster: CGA conformal transformation
            boosterVerts.push(boosterTransform(v, p1, p2, boostAmount));
        }
        
        updateMeshVertices(meshes.rotor.transformed, rotorVerts);
        updateMeshVertices(meshes.motor.transformed, motorVerts);
        updateMeshVertices(meshes.booster.transformed, boosterVerts);
        
        updateGenerators(rotorAxis, p1, p2);
    }
    
    function updateMeshVertices(mesh, vertices) {
        const positions = mesh.geometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i++) {
            positions[i * 3] = vertices[i][0];
            positions[i * 3 + 1] = vertices[i][1];
            positions[i * 3 + 2] = vertices[i][2];
        }
        mesh.geometry.attributes.position.needsUpdate = true;
        mesh.geometry.computeVertexNormals();
    }
    
    function updateGenerators(rotorAxis, p1, p2) {
        // Rotor axis
        const rg = meshes.rotor.generator;
        while (rg.children.length) rg.remove(rg.children[0]);
        const len = Math.sqrt(rotorAxis[0]**2 + rotorAxis[1]**2 + rotorAxis[2]**2);
        if (len > EPSILON) {
            const ax = rotorAxis[0]/len, ay = rotorAxis[1]/len, az = rotorAxis[2]/len;
            rg.add(new THREE.ArrowHelper(new THREE.Vector3(ax, ay, az), new THREE.Vector3(0,0,0), 2, 0xffdc00, 0.3, 0.15));
        }
        
        // Motor screw axis
        const mg = meshes.motor.generator;
        while (mg.children.length) mg.remove(mg.children[0]);
        mg.add(new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,-3), new THREE.Vector3(0,0,3)]),
            new THREE.LineBasicMaterial({ color: 0xffdc00 })
        ));
        
        // Booster point pair
        const bg = meshes.booster.generator;
        while (bg.children.length) bg.remove(bg.children[0]);
        const sphGeo = new THREE.SphereGeometry(0.12, 16, 16);
        const sphMat = new THREE.MeshBasicMaterial({ color: 0xffdc00 });
        const s1 = new THREE.Mesh(sphGeo, sphMat); s1.position.set(...p1); bg.add(s1);
        const s2 = new THREE.Mesh(sphGeo, sphMat); s2.position.set(...p2); bg.add(s2);
        bg.add(new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(...p1), new THREE.Vector3(...p2)]),
            new THREE.LineBasicMaterial({ color: 0xffdc00 })
        ));
    }
    
    function updateSliderDisplays() {
        document.getElementById('rotorAngleVal').textContent = Math.round(parseFloat(document.getElementById('rotorAngle').value)) + '¬∞';
        document.getElementById('rotorAxisXVal').textContent = parseFloat(document.getElementById('rotorAxisX').value).toFixed(1);
        document.getElementById('rotorAxisYVal').textContent = parseFloat(document.getElementById('rotorAxisY').value).toFixed(1);
        document.getElementById('rotorAxisZVal').textContent = parseFloat(document.getElementById('rotorAxisZ').value).toFixed(1);
        document.getElementById('motorRotVal').textContent = Math.round(parseFloat(document.getElementById('motorRot').value)) + '¬∞';
        document.getElementById('motorTransVal').textContent = parseFloat(document.getElementById('motorTrans').value).toFixed(1);
        document.getElementById('boostAmountVal').textContent = parseFloat(document.getElementById('boostAmount').value).toFixed(2);
        document.getElementById('boostSepVal').textContent = parseFloat(document.getElementById('boostSep').value).toFixed(1);
        document.getElementById('gridResVal').textContent = document.getElementById('gridRes').value;
    }
    
    function animate() {
        requestAnimationFrame(animate);
        
        if (animating) {
            animationTime += 0.02;
            document.getElementById('rotorAngle').value = Math.sin(animationTime) * 90;
            document.getElementById('motorRot').value = Math.sin(animationTime * 0.7) * 90;
            document.getElementById('motorTrans').value = Math.sin(animationTime * 0.5) * 1.5;
            document.getElementById('boostAmount').value = Math.sin(animationTime * 0.8) * 0.6;
            updateSliderDisplays();
            updateTransformations();
        }
        
        const time = Date.now() * 0.0003;
        for (const key in cameras) {
            cameras[key].position.x = Math.sin(time) * 5;
            cameras[key].position.z = Math.cos(time) * 5;
            cameras[key].lookAt(0, 0, 0);
        }
        
        for (const key in renderers) {
            renderers[key].render(scenes[key], cameras[key]);
        }
    }
    
    function init() {
        initPanel('rotorPanel');
        initPanel('motorPanel');
        initPanel('boosterPanel');
        createMeshes();
        
        document.querySelectorAll('input[type="range"]').forEach(s => 
            s.addEventListener('input', () => { updateSliderDisplays(); updateTransformations(); })
        );
        document.getElementById('meshType').addEventListener('change', createMeshes);
        document.getElementById('gridRes').addEventListener('change', createMeshes);
        document.getElementById('boostAxis').addEventListener('change', updateTransformations);
        
        document.getElementById('animateBtn').addEventListener('click', () => {
            animating = !animating;
            document.getElementById('animateBtn').textContent = animating ? '‚è∏ Pause' : '‚ñ∂ Animate';
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            animating = false;
            document.getElementById('animateBtn').textContent = '‚ñ∂ Animate';
            document.getElementById('rotorAngle').value = 45;
            document.getElementById('rotorAxisX').value = 0;
            document.getElementById('rotorAxisY').value = 0;
            document.getElementById('rotorAxisZ').value = 1;
            document.getElementById('motorRot').value = 30;
            document.getElementById('motorTrans').value = 0.5;
            document.getElementById('boostAmount').value = 0.3;
            document.getElementById('boostSep').value = 2;
            updateSliderDisplays();
            updateTransformations();
        });
        
        updateSliderDisplays();
        
        window.addEventListener('resize', () => {
            for (const key in renderers) {
                const container = document.getElementById(key);
                cameras[key].aspect = container.clientWidth / container.clientHeight;
                cameras[key].updateProjectionMatrix();
                renderers[key].setSize(container.clientWidth, container.clientHeight);
            }
        });
        
        animate();
    }
    
    document.readyState === 'loading' ? document.addEventListener('DOMContentLoaded', init) : init();
    </script>
</body>
</html>
