<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Versor Extensions Demo - Geometric Algebra Skill</title>
    <style>
        :root { --bg: #1a1a2e; --surface: #16213e; --primary: #0f3460; --accent: #e94560; --text: #eee; --text-dim: #888; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 30px; }
        h1 { font-size: 2.5rem; color: var(--accent); margin-bottom: 10px; }
        .subtitle { color: var(--text-dim); font-size: 1.1rem; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; }
        .card { background: var(--surface); border-radius: 12px; padding: 20px; border: 1px solid var(--primary); }
        .card h2 { color: var(--accent); font-size: 1.3rem; margin-bottom: 15px; border-bottom: 1px solid var(--primary); padding-bottom: 10px; }
        canvas { width: 100%; height: 300px; background: #0a0a15; border-radius: 8px; display: block; margin-bottom: 15px; }
        .controls { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px; }
        .control-group { flex: 1; min-width: 120px; }
        label { display: block; font-size: 0.85rem; color: var(--text-dim); margin-bottom: 5px; }
        input[type="range"] { width: 100%; accent-color: var(--accent); }
        input[type="number"] { width: 100%; padding: 8px; background: var(--bg); border: 1px solid var(--primary); border-radius: 4px; color: var(--text); }
        button { padding: 10px 20px; background: var(--accent); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; }
        button:hover { background: #ff6b7a; }
        button.secondary { background: var(--primary); }
        .output { background: var(--bg); padding: 12px; border-radius: 6px; font-family: 'Fira Code', monospace; font-size: 0.85rem; white-space: pre-wrap; max-height: 200px; overflow-y: auto; border: 1px solid var(--primary); }
        .output .label { color: var(--accent); }
        .output .value { color: #7fdbff; }
        .output .comment { color: var(--text-dim); }
        .info-box { background: rgba(233, 69, 96, 0.1); border-left: 3px solid var(--accent); padding: 12px; margin: 15px 0; font-size: 0.9rem; }
        code { background: var(--bg); padding: 2px 6px; border-radius: 3px; font-family: 'Fira Code', monospace; font-size: 0.85em; }
        .legend { display: flex; gap: 15px; margin-top: 10px; font-size: 0.85rem; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 2px; }
        .full-width { grid-column: 1 / -1; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üåÄ Versor Extensions Demo</h1>
            <p class="subtitle">Using ga_vanilla.js + ga_versor_extensions.js from geometric-algebra skill</p>
        </header>

        <div class="grid">
            <!-- BOOSTER DEMO -->
            <div class="card">
                <h2>üöÄ Booster (Conformal Boost)</h2>
                <canvas id="boostCanvas"></canvas>
                <div class="info-box">
                    <strong>Boosters</strong> bend elements around an "orbit" defined by a point pair.
                    <br><code>booster = cga.Gen.bst(P1.wedge(P2).scale(amount))</code>
                </div>
                <div class="controls">
                    <div class="control-group"><label>Boost Amount</label><input type="range" id="boostAmount" min="-2" max="2" step="0.05" value="0.5"></div>
                    <div class="control-group"><label>Point Pair Separation</label><input type="range" id="ppSeparation" min="0.5" max="3" step="0.1" value="1.5"></div>
                </div>
                <div class="controls">
                    <button onclick="animateBoost()">‚ñ∂ Animate</button>
                    <button class="secondary" onclick="resetBoost()">Reset</button>
                </div>
                <div class="legend">
                    <div class="legend-item"><div class="legend-color" style="background:#e94560"></div> Point Pair</div>
                    <div class="legend-item"><div class="legend-color" style="background:#7fdbff"></div> Original</div>
                    <div class="legend-item"><div class="legend-color" style="background:#2ecc40"></div> Boosted</div>
                </div>
                <h3 style="margin-top:15px;font-size:1rem;">Output</h3>
                <div class="output" id="boostOutput"></div>
            </div>

            <!-- TANGENT ELEMENTS DEMO -->
            <div class="card">
                <h2>üìç Tangent Elements</h2>
                <canvas id="tangentCanvas"></canvas>
                <div class="info-box">
                    <strong>Tangent vectors</strong> are localized at a point:
                    <br><code>tnv = cga.tangentVector(px, py, pz, vx, vy, vz)</code>
                </div>
                <div class="controls">
                    <div class="control-group"><label>Point X</label><input type="number" id="tnvPx" value="0" step="0.1"></div>
                    <div class="control-group"><label>Point Y</label><input type="number" id="tnvPy" value="0" step="0.1"></div>
                    <div class="control-group"><label>Dir X</label><input type="number" id="tnvDx" value="1" step="0.1"></div>
                    <div class="control-group"><label>Dir Y</label><input type="number" id="tnvDy" value="0.5" step="0.1"></div>
                </div>
                <button onclick="updateTangent()">Update Tangent</button>
                <h3 style="margin-top:15px;font-size:1rem;">Output</h3>
                <div class="output" id="tangentOutput"></div>
            </div>

            <!-- ROUND OPERATIONS DEMO -->
            <div class="card">
                <h2>‚≠ï Round Operations</h2>
                <canvas id="roundCanvas"></canvas>
                <div class="info-box">
                    <strong>Round elements</strong> include circles, spheres, point pairs.
                    <br><code>dls = cga.Round.dls(cx, cy, cz, radius)</code>
                </div>
                <div class="controls">
                    <div class="control-group"><label>Center X</label><input type="number" id="circCx" value="0" step="0.1"></div>
                    <div class="control-group"><label>Center Y</label><input type="number" id="circCy" value="0" step="0.1"></div>
                    <div class="control-group"><label>Radius (neg=imaginary)</label><input type="range" id="circR" min="-2" max="2" step="0.1" value="1"></div>
                </div>
                <button onclick="updateRound()">Analyze</button>
                <h3 style="margin-top:15px;font-size:1rem;">Round Properties</h3>
                <div class="output" id="roundOutput"></div>
            </div>

            <!-- DIRECTION ELEMENTS DEMO -->
            <div class="card">
                <h2>‚û°Ô∏è Direction Elements</h2>
                <canvas id="directionCanvas"></canvas>
                <div class="info-box">
                    <strong>Direction vectors</strong> are "free" vectors without position:
                    <br><code>drv = cga.directionVector(vx, vy, vz)</code>
                </div>
                <div class="controls">
                    <div class="control-group"><label>Direction X</label><input type="range" id="drvX" min="-1" max="1" step="0.05" value="1"></div>
                    <div class="control-group"><label>Direction Y</label><input type="range" id="drvY" min="-1" max="1" step="0.05" value="0"></div>
                    <div class="control-group"><label>Rotation</label><input type="range" id="drvRot" min="0" max="6.28" step="0.05" value="0"></div>
                </div>
                <button onclick="updateDirection()">Apply Rotation</button>
                <h3 style="margin-top:15px;font-size:1rem;">Output</h3>
                <div class="output" id="directionOutput"></div>
            </div>

            <!-- BOOSTED SURFACE DEMO - FULL WIDTH -->
            <div class="card full-width">
                <h2>üåä Boosted Surface Generation</h2>
                <canvas id="surfaceCanvas" style="height: 400px;"></canvas>
                <div class="info-box">
                    <strong>Colapinto's boosted surfaces</strong> - Multiple point pair generators create organic deformations.
                    Each generator: <code>cga.Gen.bst(P1.wedge(P2).scale(weight))</code>
                </div>
                <div class="controls">
                    <div class="control-group"><label>Generator 1</label><input type="range" id="gen1Str" min="-1" max="1" step="0.05" value="0.3"></div>
                    <div class="control-group"><label>Generator 2</label><input type="range" id="gen2Str" min="-1" max="1" step="0.05" value="-0.2"></div>
                    <div class="control-group"><label>Generator 3</label><input type="range" id="gen3Str" min="-1" max="1" step="0.05" value="0.4"></div>
                    <div class="control-group"><label>Grid Resolution</label><input type="range" id="gridRes" min="5" max="25" step="1" value="15"></div>
                </div>
                <div class="controls">
                    <button onclick="animateSurface()">‚ñ∂ Animate</button>
                    <button class="secondary" onclick="resetSurface()">Reset</button>
                    <button class="secondary" onclick="randomizeGenerators()">Randomize</button>
                </div>
                <div class="legend">
                    <div class="legend-item"><div class="legend-color" style="background:#e94560"></div> Generator 1</div>
                    <div class="legend-item"><div class="legend-color" style="background:#7fdbff"></div> Generator 2</div>
                    <div class="legend-item"><div class="legend-color" style="background:#ffdc00"></div> Generator 3</div>
                    <div class="legend-item"><div class="legend-color" style="background:#2ecc40"></div> Deformed Grid</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load GA skill scripts -->
    <script src="ga_vanilla.js"></script>
    <script src="ga_versor_extensions.js"></script>
    
    <script>
        // ============================================================================
        // Initialize CGA from skill
        // ============================================================================
        const cga = new VersorGA.CGA3DVersor();
        
        let boostAnimating = false, surfaceAnimating = false;
        let boostTime = 0, surfaceTime = 0;
        
        // ============================================================================
        // Canvas utilities
        // ============================================================================
        function getCtx(id) {
            const canvas = document.getElementById(id);
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            return { ctx, w: canvas.offsetWidth, h: canvas.offsetHeight };
        }
        
        function toScreen(x, y, w, h, scale = 50) {
            return [w/2 + x * scale, h/2 - y * scale];
        }
        
        function drawPoint(ctx, x, y, w, h, color = '#e94560', size = 5) {
            const [sx, sy] = toScreen(x, y, w, h);
            ctx.beginPath();
            ctx.arc(sx, sy, size, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        function drawLine(ctx, x1, y1, x2, y2, w, h, color = '#7fdbff', width = 2) {
            const [sx1, sy1] = toScreen(x1, y1, w, h);
            const [sx2, sy2] = toScreen(x2, y2, w, h);
            ctx.beginPath();
            ctx.moveTo(sx1, sy1);
            ctx.lineTo(sx2, sy2);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
        }
        
        function drawCircle(ctx, cx, cy, r, w, h, color = '#7fdbff', width = 2, dashed = false) {
            const [sx, sy] = toScreen(cx, cy, w, h);
            ctx.beginPath();
            ctx.arc(sx, sy, Math.abs(r) * 50, 0, Math.PI * 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            if (dashed) ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawArrow(ctx, x1, y1, x2, y2, w, h, color = '#7fdbff', width = 2) {
            drawLine(ctx, x1, y1, x2, y2, w, h, color, width);
            const [sx1, sy1] = toScreen(x1, y1, w, h);
            const [sx2, sy2] = toScreen(x2, y2, w, h);
            const angle = Math.atan2(sy2 - sy1, sx2 - sx1);
            const headLen = 10;
            ctx.beginPath();
            ctx.moveTo(sx2, sy2);
            ctx.lineTo(sx2 - headLen * Math.cos(angle - 0.4), sy2 - headLen * Math.sin(angle - 0.4));
            ctx.lineTo(sx2 - headLen * Math.cos(angle + 0.4), sy2 - headLen * Math.sin(angle + 0.4));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        function drawGrid(ctx, w, h, color = '#333') {
            ctx.strokeStyle = color;
            ctx.lineWidth = 0.5;
            for (let x = -5; x <= 5; x++) {
                const [sx] = toScreen(x, 0, w, h);
                ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, h); ctx.stroke();
            }
            for (let y = -5; y <= 5; y++) {
                const [, sy] = toScreen(0, y, w, h);
                ctx.beginPath(); ctx.moveTo(0, sy); ctx.lineTo(w, sy); ctx.stroke();
            }
        }
        
        // ============================================================================
        // BOOSTER DEMO - Uses cga.Gen.bst() and cga.spin()
        // ============================================================================
        function updateBoost() {
            const { ctx, w, h } = getCtx('boostCanvas');
            ctx.clearRect(0, 0, w, h);
            drawGrid(ctx, w, h);
            
            const amount = parseFloat(document.getElementById('boostAmount').value);
            const sep = parseFloat(document.getElementById('ppSeparation').value);
            
            // Create CGA points for point pair
            const P1 = cga.point(-sep/2, 0, 0);
            const P2 = cga.point(sep/2, 0, 0);
            
            // Draw point pair
            drawPoint(ctx, -sep/2, 0, w, h, '#e94560', 8);
            drawPoint(ctx, sep/2, 0, w, h, '#e94560', 8);
            drawLine(ctx, -sep/2, 0, sep/2, 0, w, h, '#e94560', 2);
            
            // Create point pair via wedge and scale
            const pp = P1.wedge(P2);
            const scaledPP = pp.scale(amount + boostTime);
            const booster = cga.Gen.bst(scaledPP);
            
            const origPoints = [], boostedPoints = [];
            
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                const r = 2;
                const x = r * Math.cos(angle);
                const y = r * Math.sin(angle);
                
                origPoints.push([x, y]);
                
                // Apply booster using spin
                const pt = cga.point(x, y, 0);
                const transformed = cga.spin(pt, booster);
                const coords = cga.pointCoords(transformed);
                boostedPoints.push([coords[0], coords[1]]);
            }
            
            // Draw original
            for (const p of origPoints) drawPoint(ctx, p[0], p[1], w, h, '#7fdbff', 4);
            
            // Draw boosted
            for (let i = 0; i < boostedPoints.length; i++) {
                const p = boostedPoints[i];
                drawPoint(ctx, p[0], p[1], w, h, '#2ecc40', 4);
                if (i > 0) drawLine(ctx, boostedPoints[i-1][0], boostedPoints[i-1][1], p[0], p[1], w, h, '#2ecc40', 1);
            }
            drawLine(ctx, boostedPoints[boostedPoints.length-1][0], boostedPoints[boostedPoints.length-1][1],
                     boostedPoints[0][0], boostedPoints[0][1], w, h, '#2ecc40', 1);
            
            document.getElementById('boostOutput').innerHTML = 
`<span class="label">Point Pair:</span> P1=[${(-sep/2).toFixed(2)}, 0] ‚Üî P2=[${(sep/2).toFixed(2)}, 0]
<span class="label">Boost Amount:</span> <span class="value">${amount.toFixed(3)}</span>

<span class="comment">// CGA API calls:</span>
<span class="comment">const P1 = cga.point(-sep/2, 0, 0);</span>
<span class="comment">const P2 = cga.point(sep/2, 0, 0);</span>
<span class="comment">const pp = P1.wedge(P2);</span>
<span class="comment">const booster = cga.Gen.bst(pp.scale(amount));</span>
<span class="comment">const result = cga.spin(point, booster);</span>`;
        }
        
        function animateBoost() {
            boostAnimating = !boostAnimating;
            if (boostAnimating) requestAnimationFrame(boostLoop);
        }
        
        function boostLoop() {
            if (!boostAnimating) return;
            boostTime = Math.sin(Date.now() / 1000) * 0.5;
            updateBoost();
            requestAnimationFrame(boostLoop);
        }
        
        function resetBoost() {
            boostAnimating = false;
            boostTime = 0;
            document.getElementById('boostAmount').value = 0.5;
            document.getElementById('ppSeparation').value = 1.5;
            updateBoost();
        }
        
        // ============================================================================
        // TANGENT DEMO - Uses cga.tangentVector()
        // ============================================================================
        function updateTangent() {
            const { ctx, w, h } = getCtx('tangentCanvas');
            ctx.clearRect(0, 0, w, h);
            drawGrid(ctx, w, h);
            
            const px = parseFloat(document.getElementById('tnvPx').value);
            const py = parseFloat(document.getElementById('tnvPy').value);
            const dx = parseFloat(document.getElementById('tnvDx').value);
            const dy = parseFloat(document.getElementById('tnvDy').value);
            
            drawPoint(ctx, px, py, w, h, '#e94560', 8);
            drawArrow(ctx, px, py, px + dx, py + dy, w, h, '#7fdbff', 3);
            
            // Create tangent element using actual CGA
            const tnv = cga.tangentVector(px, py, 0, dx, dy, 0);
            
            document.getElementById('tangentOutput').innerHTML = 
`<span class="label">Tangent Vector (Tnv):</span>
  Location: [<span class="value">${px.toFixed(2)}, ${py.toFixed(2)}, 0</span>]
  Direction: [<span class="value">${dx.toFixed(2)}, ${dy.toFixed(2)}, 0</span>]
  Magnitude: <span class="value">${Math.sqrt(dx*dx + dy*dy).toFixed(3)}</span>

<span class="comment">// CGA API:</span>
<span class="comment">const tnv = cga.tangentVector(px, py, 0, dx, dy, 0);</span>
<span class="comment">// Tnv = Point ‚àß (Direction ‚àß n‚àû)</span>`;
        }
        
        // ============================================================================
        // ROUND DEMO - Uses cga.Round namespace
        // ============================================================================
        function updateRound() {
            const { ctx, w, h } = getCtx('roundCanvas');
            ctx.clearRect(0, 0, w, h);
            drawGrid(ctx, w, h);
            
            const cx = parseFloat(document.getElementById('circCx').value);
            const cy = parseFloat(document.getElementById('circCy').value);
            const r = parseFloat(document.getElementById('circR').value);
            
            // Create dual sphere using CGA
            const dls = cga.Round.dls(cx, cy, 0, r);
            const isImaginary = cga.Round.isImaginary(dls);
            
            drawCircle(ctx, cx, cy, Math.abs(r), w, h, isImaginary ? '#ff6b7a' : '#7fdbff', 2, isImaginary);
            drawPoint(ctx, cx, cy, w, h, '#e94560', 6);
            
            document.getElementById('roundOutput').innerHTML = 
`<span class="label">Dual Sphere:</span>
  Center: [<span class="value">${cx.toFixed(2)}, ${cy.toFixed(2)}, 0</span>]
  Radius: <span class="value">${r.toFixed(2)}</span>
  Type: ${isImaginary ? '<span style="color:#ff6b7a">Imaginary (r¬≤ < 0)</span>' : '<span class="value">Real</span>'}

<span class="comment">// CGA API:</span>
<span class="comment">const dls = cga.Round.dls(cx, cy, 0, r);</span>
<span class="comment">const isImag = cga.Round.isImaginary(dls);</span>
<span class="comment">const size = cga.Round.size(dls);</span>`;
        }
        
        // ============================================================================
        // DIRECTION DEMO - Uses cga.directionVector()
        // ============================================================================
        function updateDirection() {
            const { ctx, w, h } = getCtx('directionCanvas');
            ctx.clearRect(0, 0, w, h);
            drawGrid(ctx, w, h);
            
            const dx = parseFloat(document.getElementById('drvX').value);
            const dy = parseFloat(document.getElementById('drvY').value);
            const rot = parseFloat(document.getElementById('drvRot').value);
            
            // Create direction vector
            const drv = cga.directionVector(dx, dy, 0);
            
            // Draw from multiple points to show "free" nature
            const points = [[0,0], [-2,1], [1,-1], [2,2]];
            for (const [px, py] of points) {
                drawPoint(ctx, px, py, w, h, '#444', 4);
                drawArrow(ctx, px, py, px + dx, py + dy, w, h, '#7fdbff', 2);
            }
            
            // Rotated direction
            const c = Math.cos(rot), s = Math.sin(rot);
            const rdx = dx * c - dy * s;
            const rdy = dx * s + dy * c;
            
            for (const [px, py] of points) {
                drawArrow(ctx, px, py, px + rdx, py + rdy, w, h, '#2ecc40', 2);
            }
            
            document.getElementById('directionOutput').innerHTML = 
`<span class="label">Direction Vector (Drv):</span>
  Original: [<span class="value">${dx.toFixed(2)}, ${dy.toFixed(2)}</span>]
  Rotated: [<span class="value">${rdx.toFixed(2)}, ${rdy.toFixed(2)}</span>]
  Rotation: <span class="value">${(rot * 180 / Math.PI).toFixed(1)}¬∞</span>

<span class="comment">// CGA API:</span>
<span class="comment">const drv = cga.directionVector(dx, dy, 0);</span>
<span class="comment">// Drv = v ‚àß n‚àû (free vector, same at all positions)</span>`;
        }
        
        // ============================================================================
        // BOOSTED SURFACE DEMO - Multiple generators
        // ============================================================================
        function updateSurface() {
            const { ctx, w, h } = getCtx('surfaceCanvas');
            ctx.clearRect(0, 0, w, h);
            
            const gen1Str = parseFloat(document.getElementById('gen1Str').value);
            const gen2Str = parseFloat(document.getElementById('gen2Str').value);
            const gen3Str = parseFloat(document.getElementById('gen3Str').value);
            const gridRes = parseInt(document.getElementById('gridRes').value);
            
            const generators = [
                { p1: [-2, -1, 0], p2: [-2, 1, 0], weight: gen1Str, color: '#e94560' },
                { p1: [2, -0.5, 0], p2: [2, 0.5, 0], weight: gen2Str, color: '#7fdbff' },
                { p1: [0, 2, 0], p2: [0, -2, 0], weight: gen3Str, color: '#ffdc00' }
            ];
            
            // Draw generator point pairs
            for (const gen of generators) {
                drawLine(ctx, gen.p1[0], gen.p1[1], gen.p2[0], gen.p2[1], w, h, gen.color, 3);
                drawPoint(ctx, gen.p1[0], gen.p1[1], w, h, gen.color, 6);
                drawPoint(ctx, gen.p2[0], gen.p2[1], w, h, gen.color, 6);
            }
            
            // Create boosters using actual CGA
            const boosters = generators.map((gen, idx) => {
                const P1 = cga.point(gen.p1[0], gen.p1[1], gen.p1[2]);
                const P2 = cga.point(gen.p2[0], gen.p2[1], gen.p2[2]);
                const pp = P1.wedge(P2);
                const animOffset = surfaceAnimating ? Math.sin(surfaceTime + idx) * 0.2 : 0;
                return cga.Gen.bst(pp.scale(gen.weight + animOffset));
            });
            
            // Generate and transform grid
            const extent = 3;
            const step = (extent * 2) / gridRes;
            const transformedGrid = [];
            
            for (let i = 0; i <= gridRes; i++) {
                const row = [];
                for (let j = 0; j <= gridRes; j++) {
                    let pt = cga.point(-extent + i * step, -extent + j * step, 0);
                    
                    // Apply each booster
                    for (const booster of boosters) {
                        pt = cga.spin(pt, booster);
                    }
                    
                    const coords = cga.pointCoords(pt);
                    row.push([coords[0], coords[1]]);
                }
                transformedGrid.push(row);
            }
            
            // Draw grid
            ctx.strokeStyle = '#2ecc40';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= gridRes; i++) {
                ctx.beginPath();
                for (let j = 0; j <= gridRes; j++) {
                    const [x, y] = transformedGrid[i][j];
                    const [sx, sy] = toScreen(x, y, w, h, 60);
                    if (j === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
            }
            
            for (let j = 0; j <= gridRes; j++) {
                ctx.beginPath();
                for (let i = 0; i <= gridRes; i++) {
                    const [x, y] = transformedGrid[i][j];
                    const [sx, sy] = toScreen(x, y, w, h, 60);
                    if (i === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                }
                ctx.stroke();
            }
        }
        
        function animateSurface() {
            surfaceAnimating = !surfaceAnimating;
            if (surfaceAnimating) requestAnimationFrame(surfaceLoop);
        }
        
        function surfaceLoop() {
            if (!surfaceAnimating) return;
            surfaceTime = Date.now() / 500;
            updateSurface();
            requestAnimationFrame(surfaceLoop);
        }
        
        function resetSurface() {
            surfaceAnimating = false;
            surfaceTime = 0;
            document.getElementById('gen1Str').value = 0.3;
            document.getElementById('gen2Str').value = -0.2;
            document.getElementById('gen3Str').value = 0.4;
            document.getElementById('gridRes').value = 15;
            updateSurface();
        }
        
        function randomizeGenerators() {
            document.getElementById('gen1Str').value = (Math.random() - 0.5) * 2;
            document.getElementById('gen2Str').value = (Math.random() - 0.5) * 2;
            document.getElementById('gen3Str').value = (Math.random() - 0.5) * 2;
            updateSurface();
        }
        
        // ============================================================================
        // Initialize
        // ============================================================================
        function init() {
            document.getElementById('boostAmount').addEventListener('input', updateBoost);
            document.getElementById('ppSeparation').addEventListener('input', updateBoost);
            document.getElementById('circR').addEventListener('input', updateRound);
            document.getElementById('drvX').addEventListener('input', updateDirection);
            document.getElementById('drvY').addEventListener('input', updateDirection);
            document.getElementById('drvRot').addEventListener('input', updateDirection);
            document.getElementById('gen1Str').addEventListener('input', updateSurface);
            document.getElementById('gen2Str').addEventListener('input', updateSurface);
            document.getElementById('gen3Str').addEventListener('input', updateSurface);
            document.getElementById('gridRes').addEventListener('input', updateSurface);
            
            updateBoost();
            updateTangent();
            updateRound();
            updateDirection();
            updateSurface();
        }
        
        window.addEventListener('resize', () => {
            updateBoost();
            updateTangent();
            updateRound();
            updateDirection();
            updateSurface();
        });
        
        init();
    </script>
</body>
</html>
