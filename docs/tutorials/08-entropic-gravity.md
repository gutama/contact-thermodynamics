# Tutorial 8: Entropic Gravity

This tutorial introduces the integration of Bianconi's "Gravity from Entropy" framework with the GMET contact geometry library.

## Overview

The `entropic-gravity` module implements a complete framework where **gravity emerges from information geometry**. The key insight is that gravitational dynamics arise from minimizing the "information distance" between two metrics:

1. **Spacetime Metric ($g$)**: The quantum operator defining geometry
2. **Matter-Induced Metric ($G$)**: The classical state defined by matter fields (scalar $\phi$, gauge $A$, 2-form $B$)

The module provides:
- **Tensor formulation**: Standard $S(G||g)$ relative entropy
- **Geometric Algebra formulation**: Curvature 2-form $\Omega = d\omega + \omega \wedge \omega$
- **Constitutive relations**: Bridge between thermodynamic entropy $S$ and geometric entropy

## Theoretical Framework

### The Two-Metric System

The core object is the interplay between spacetime metric $g_{\mu\nu}$ and matter-induced metric $G_{\mu\nu}$:

$$G_{\mu\nu} = R_{\mu\nu} + \partial_\mu\phi \partial_\nu\phi + F_{\mu\rho} F_\nu^{\ \rho} + H_{\mu\rho\sigma} H_\nu^{\ \rho\sigma}$$

Where:
- $\phi$: scalar field (0-form)
- $F = dA$: gauge field strength (2-form from 1-form $A$)
- $H = dB$: 3-form field strength (from 2-form $B$)
- $R_{\mu\nu}$: Ricci tensor from $g$

### Relative Entropy Action

The dynamics are generated by minimizing the **Quantum Relative Entropy**:

$$S(G||g) = \int d^4x \sqrt{|g|} \text{Tr}[G(\ln G - \ln g)]$$

### Emergent Cosmological Constant

A key prediction: $\Lambda$ is not a free parameter but emerges from the metric mismatch:

$$\Lambda_G = \frac{1}{4} \text{Tr}(G \cdot g^{-1} - 4I)$$

---

## Basic Usage

### 1. Two-Metric System

```javascript
const EntropicGravity = require('../src/entropic-gravity.js');

// 1. Define Spacetime Metric (g) - Schwarzschild black hole
const g = EntropicGravity.StandardMetrics.schwarzschild(1.0);  // M = 1

// 2. Define Matter-Induced Metric (G)
const G = new EntropicGravity.MatterInducedMetric({
    // Scalar field φ(x) - dilaton-like
    scalarField: x => Math.exp(-(x[1]**2 + x[2]**2 + x[3]**2)),

    // Vector potential A_μ(x) - Coulomb
    vectorPotential: x => {
        const r = Math.sqrt(x[1]**2 + x[2]**2 + x[3]**2 + 0.01);
        return [1/r, 0, 0, 0];
    },

    // Ricci tensor contribution (optional)
    ricciTensor: x => [[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]
});

// 3. Create Two-Metric System
const system = new EntropicGravity.TwoMetricSystem(g, G);
```

### 2. Relative Entropy Action

```javascript
const action = new EntropicGravity.RelativeEntropyAction(system);

// Local entropy density at spacetime point
const x = [0, 5, Math.PI/2, 0];  // (t, r, θ, φ)
const density = action.localDensity(x);
console.log('Local entropy density:', density);

// Total action over a region
const bounds = [[-1, 1], [3, 10], [0, Math.PI], [0, 2*Math.PI]];
const S_total = action.totalAction(bounds, 5);
console.log('Total action:', S_total);

// Entropic stress-energy tensor δS/δg
const T_ent = action.variationWrtMetric(x);
```

### 3. Emergent Cosmological Constant

```javascript
const lambda = new EntropicGravity.EmergentCosmologicalConstant(system);

// Local Λ value
const Lambda_val = lambda.localValue([0, 10, Math.PI/2, 0]);
console.log('Emergent Λ:', Lambda_val);

// Classify spacetime type
const type = lambda.classify([0, 10, Math.PI/2, 0]);
// Returns: 'de Sitter (Λ > 0)', 'anti-de Sitter (Λ < 0)', or 'Minkowski (Λ ≈ 0)'
```

---

## Integration with GMET

The entropic action serves as a potential in the contact Hamiltonian:

$$H = H_{geo} + \alpha \cdot S(G||g)$$

where $H_{geo} = \frac{1}{2} g^{\mu\nu}(p_\mu - qA_\mu)(p_\nu - qA_\nu) - \frac{1}{2}m^2$

```javascript
const GMET = require('../src/index.js');

// Create Grand Contact Manifold M₁₃ = J¹(Q₆)
const M13 = new GMET.GrandContactManifold();

// Create Entropic Hamiltonian
const H = new EntropicGravity.EntropicGravityHamiltonian(M13, system, {
    mass: 1.0,
    entropicCoupling: 0.01,  // Coupling strength α
    useGA: false             // Tensor mode (see GA section below)
});

// Create initial state in contact phase space
const p0 = M13.physicalPoint(
    10, Math.PI/2, 0, // Position: r, θ, φ
    0,                // Time t
    0,                // Log-scale ℓ
    1.0,              // Entropy S
    -0.02, 0, 0.01,   // Momenta: k_r, k_θ, k_φ
    1.0,              // Frequency ω
    0,                // Dilatation Δ
    1.0,              // Temperature T
    0                 // Action A
);

// Integrate trajectory
const trajectory = H.flow(p0, 0.1, 100);

// Analyze results
const final = trajectory[trajectory.length - 1];
console.log('Final radius:', final.get('q1'));
console.log('Entropy change:', final.get('S') - p0.get('S'));
console.log('Action accumulated:', final.get('A'));
```

---

## Geometric Algebra Formulation (NEW)

The module supports a **coordinate-free formulation** using Spacetime Geometric Algebra Cl(1,3).

### Why GA?

Instead of minimizing $S(G||g)$ via tensor calculus, we express the "entropic potential" directly via the **Curvature 2-Form**:

$$\Omega_{ab} = \partial_a \omega_b - \partial_b \omega_a + [\omega_a, \omega_b]$$

where $\omega_\mu$ are the **connection bivectors** (replacing Christoffel symbols).

The entropic Hamiltonian becomes:

$$H_{ent} = \alpha \cdot |\Omega|^2 = \alpha \sum_{a<b} \eta^{aa}\eta^{bb} \langle \Omega_{ab} \tilde{\Omega}_{ab} \rangle$$

### Usage

```javascript
// Enable GA mode
const H_ga = new EntropicGravity.EntropicGravityHamiltonian(M13, system, {
    mass: 1.0,
    entropicCoupling: 0.01,
    useGA: true,        // Activate Cl(1,3) solver
    useCurvature: true  // Use full Ω (vs just |ω|²)
});

// The GA manifold is available for direct computation
const x = [0, 5, Math.PI/2, 0];

// Connection bivectors ω_μ
const omegas = H_ga.gaManifold.connectionBivector(x);

// Full curvature 2-form Ω_ab
const Omega = H_ga.gaManifold.curvature2Form(x);

// Riemann tensor R^a_bcd
const R = H_ga.gaManifold.riemannTensor(x);

// Ricci tensor R_ab
const Ric = H_ga.gaManifold.ricciTensor(x);

// Ricci scalar R
const RicciScalar = H_ga.gaManifold.ricciScalar(x);

// Curvature density |Ω|² (used in entropic force)
const curvatureDensity = H_ga.gaManifold.curvatureNormSquared(x);
```

### Tensor vs GA Comparison

Both formulations are physically equivalent but mathematically distinct:

| Aspect | Tensor | Geometric Algebra |
|--------|--------|-------------------|
| Entropic density | $\text{Tr}[G(ln G - ln g)]$ | $|\Omega|^2$ |
| Connection | Christoffel $\Gamma^\lambda_{\mu\nu}$ | Bivector $\omega_\mu$ |
| Curvature | Riemann $R^\lambda_{\ \mu\nu\rho}$ | 2-form $\Omega_{ab}$ |
| Computation | Index gymnastics | Geometric products |

---

## Constitutive Relation: S ↔ G Bridge (NEW)

The **constitutive relation** bridges GMET's thermodynamic sector to Bianconi's geometric sector:

- **S** (GMET coordinate): Thermodynamic entropy of local fluid element
- **G** (Bianconi metric): Geometric entropy from matter fields

### The Bridge Function

The matter-induced metric scales with thermodynamic state:

$$G_{\mu\nu}(x; S, T) = f(S, T) \cdot G^{base}_{\mu\nu}(x)$$

where $f(S, T)$ is the **constitutive function**.

### Available Models

```javascript
const { ConstitutiveRelation, ConstitutiveModels } = EntropicGravity;

// 1. Boltzmann: Higher S → thermalized matter → less G contribution
//    f = κ · exp(-β(S - S₀)/T)
const boltzmann = ConstitutiveModels.boltzmann(1.0);

// 2. Black Hole (Bekenstein-Hawking inspired)
//    f = κ · T² / S  (relates to S = A/4, T ∝ 1/M)
const blackHole = ConstitutiveModels.blackHole(1.0);

// 3. Cosmological (power-law for inflation)
//    f = κ · (S/S₀)^β
const cosmological = ConstitutiveModels.cosmological(2.0);

// 4. Phase Transition (Fermi-Dirac)
//    f = κ / (1 + exp(β(S - S_crit)/T))
const phaseTransition = ConstitutiveModels.phaseTransition(5.0, 1.0);

// 5. Information-Theoretic
//    f = κ · exp(S/S₀) · (1 - exp(-T/T₀))
const infoGeom = ConstitutiveModels.informationGeometry();
```

### Custom Constitutive Relations

```javascript
// Create custom model
const custom = new ConstitutiveRelation({
    model: 'power',
    params: {
        kappa: 0.5,   // Coupling strength
        S0: 2.0,      // Reference entropy
        T0: 1.0,      // Reference temperature
        beta: 1.5     // Power exponent
    }
});

// Evaluate scaling factor
const f = custom.scalingFactor(S=1.5, T=1.0);

// Compute derivatives (for dynamics)
const dfdS = custom.dfdS(1.5, 1.0);
const dfdT = custom.dfdT(1.5, 1.0);

// Gravitational heat capacity
const C_G = custom.gravitationalHeatCapacity(1.5, 1.0);
```

### Using with Hamiltonian

```javascript
// Create constitutive relation
const constitutive = ConstitutiveModels.boltzmann(1.0);

// Attach to Hamiltonian
const H = new EntropicGravity.EntropicGravityHamiltonian(M13, system, {
    mass: 1.0,
    entropicCoupling: 0.01,
    useGA: true,
    constitutive: constitutive  // S↔G bridge
});

// The entropic force now depends on thermodynamic state (S, T)
// from the GMET contact coordinates
```

### ThermodynamicMatterMetric

For full coupling, use `ThermodynamicMatterMetric`:

```javascript
const { ThermodynamicMatterMetric, ConstitutiveRelation } = EntropicGravity;

// Create matter metric with constitutive coupling
const constitutive = new ConstitutiveRelation({ model: 'linear' });
const thermoMatter = new ThermodynamicMatterMetric({
    scalarField: x => Math.exp(-x[1]**2)
}, constitutive);

// Set thermodynamic state
thermoMatter.setThermodynamicState(S=1.5, T=1.0);

// Matter metric now scales with (S, T)
const G = thermoMatter.covariant([0, 1, 0, 0]);

// Or compute directly with state
const G2 = thermoMatter.covariantWithState([0, 1, 0, 0], S=2.0, T=1.5);
```

---

## Complete Example

```javascript
const GMET = require('../src/index.js');
const EntropicGravity = require('../src/entropic-gravity.js');

// 1. Setup GMET manifold
const M13 = new GMET.GrandContactManifold();

// 2. Setup metrics
const g = EntropicGravity.StandardMetrics.schwarzschild(1.0);
const G = new EntropicGravity.MatterInducedMetric({
    scalarField: x => 0.1 * Math.exp(-x[1] / 5)
});
const system = new EntropicGravity.TwoMetricSystem(g, G);

// 3. Create constitutive relation
const constitutive = EntropicGravity.ConstitutiveModels.boltzmann(1.0);

// 4. Create Hamiltonian with full features
const H = new EntropicGravity.EntropicGravityHamiltonian(M13, system, {
    mass: 0.1,
    entropicCoupling: 0.01,
    useGA: true,              // Use Geometric Algebra
    useCurvature: true,       // Use full curvature Ω
    constitutive: constitutive // S↔G bridge
});

// 5. Initial conditions
const p0 = M13.physicalPoint(
    15, Math.PI/2, 0,   // r, θ, φ
    0, 0, 1.0,          // t, ℓ, S
    -0.02, 0, 0.005,    // k_r, k_θ, k_φ
    1.0, 0, 1.0, 0      // ω, Δ, T, A
);

// 6. Integrate
const trajectory = H.flow(p0, 0.5, 100);

// 7. Analyze
console.log('Initial r:', trajectory[0].get('q1'));
console.log('Final r:', trajectory[100].get('q1'));
console.log('Entropy change:', trajectory[100].get('S') - trajectory[0].get('S'));
```

---

## Physics Interpretation

### Framework Synthesis

| Component | Role |
|-----------|------|
| **GMET M₁₃** | Kinematic scaffold (13D contact manifold) |
| **Spacetime g** | Background geometry (quantum operator) |
| **Matter G** | Dressed geometry (classical state from φ, A, B) |
| **S(G‖g)** | Information distance (relative entropy) |
| **Λ_G** | Emergent from trace constraint |
| **Ω = dω + ω∧ω** | Curvature 2-form (GA formulation) |
| **f(S,T)** | Constitutive bridge (thermodynamics ↔ geometry) |

### Key Insights

1. **Gravity from Information**: The "force" of gravity emerges from minimizing information-theoretic distance between metrics

2. **Emergent Λ**: Cosmological constant is not a free parameter but emerges dynamically from matter distribution

3. **Thermodynamic Coupling**: The constitutive relation f(S,T) makes gravity truly thermodynamic—geometry responds to entropy

4. **Coordinate-Free**: GA formulation eliminates index gymnastics while preserving full physics

---

## API Reference

### Core Classes

| Class | Description |
|-------|-------------|
| `MatterInducedMetric` | $G_{\mu\nu}$ from matter fields |
| `TwoMetricSystem` | $(g, G)$ pair management |
| `RelativeEntropyAction` | $S(G‖g)$ computation |
| `EmergentCosmologicalConstant` | $\Lambda_G$ calculation |
| `ModifiedEinsteinSolver` | Field equation residuals |
| `EntropicGravityHamiltonian` | Contact dynamics |

### Constitutive Classes

| Class | Description |
|-------|-------------|
| `ConstitutiveRelation` | f(S,T) scaling function |
| `ThermodynamicMatterMetric` | G coupled to (S,T) |
| `TwoMetricSystemWithConstitutive` | Full bridged system |

### Standard Metrics

```javascript
EntropicGravity.StandardMetrics.minkowski()
EntropicGravity.StandardMetrics.schwarzschild(M)
EntropicGravity.StandardMetrics.flrw(a_func, k)
```

### Constitutive Models

```javascript
EntropicGravity.ConstitutiveModels.boltzmann(kappa)
EntropicGravity.ConstitutiveModels.blackHole(kappa)
EntropicGravity.ConstitutiveModels.cosmological(beta)
EntropicGravity.ConstitutiveModels.phaseTransition(S_crit, T_scale)
EntropicGravity.ConstitutiveModels.informationGeometry()
```

---

## Further Reading

- Bianconi, G. (2025). "Gravity from Entropy"
- Hestenes, D. "Spacetime Algebra" (GA formulation)
- Jacobson, T. "Thermodynamics of Spacetime" (entropic gravity origins)
