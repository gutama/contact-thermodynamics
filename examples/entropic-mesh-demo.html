<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Entropic Gradient Flow on Mesh</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0a0e14;
            color: #e6e8eb;
            font-family: sans-serif;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            width: 300px;
        }

        .row {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        input[type="range"] {
            flex: 1;
            margin: 0 10px;
        }

        button {
            background: #4da6ff;
            border: none;
            padding: 8px 16px;
            color: white;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #3d8dd6;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #stats {
            font-family: monospace;
            font-size: 12px;
            margin-top: 10px;
            color: #8a94a6;
        }
    </style>
</head>

<body>
    <div id="controls">
        <h3>Entropic Gradient Flow</h3>
        <div class="row">
            <label>Scalar Field φ:</label>
            <button onclick="updateField('pole')">Pole</button>
            <button onclick="updateField('equator')">Equator</button>
        </div>
        <div class="row">
            <label>Coupling α:</label>
            <input type="range" id="coupling" min="0" max="1" step="0.01" value="0.1">
            <span id="couplingVal">0.1</span>
        </div>
        <div class="row">
            <label>Dynamic:</label>
            <input type="checkbox" id="dynamicToggle">
        </div>
        <div class="row">
            <button onclick="resetParticles()">Reset Particles</button>
        </div>
        <div id="stats">
            Particles: <span id="pCount">0</span><br>
            Time: <span id="time">0.00</span>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <!-- Simple 3D Engine (three.js inspired standard boilerplate for demos) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // We need to bridge the Node.js modules to browser.
        // Since we can't require() directly in browser without bundling, 
        // we will mock the mesh logic here OR assume a bundle exists.
        // For this demo, we will implement the core visual logic directly using Three.js
        // and emulate the EntropicMeshflow class logic within the script
        // to ensure it runs standalone without a build step.

        // --- EMULATION OF MESH I/O (Simplified for Demo) ---

        let mesh, geometry, material, particlesSystem;
        let particlePositions = []; // Array of { faceIndex, u, v }
        let entropicPotential = []; // Array of float per vertex

        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const controls = {
            coupling: 0.1,
            dynamic: false,
            time: 0
        };

        // Initialize Sphere
        const radius = 3.0;
        const detail = 3; // level of subdivision
        const sphereGeo = new THREE.IcosahedronGeometry(radius, detail);
        const positionAttribute = sphereGeo.attributes.position;
        const vertexCount = positionAttribute.count;

        // Custom Shader Material for Heatmap
        const uniforms = {
            minVal: { value: 0 },
            maxVal: { value: 1 },
            colorLow: { value: new THREE.Color(0x0000aa) },
            colorHigh: { value: new THREE.Color(0xffaa00) }
        };

        sphereGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3));

        const sphereMat = new THREE.MeshBasicMaterial({
            vertexColors: true,
            wireframe: false
        });

        const sphereWireMat = new THREE.MeshBasicMaterial({
            color: 0x444444,
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });

        mesh = new THREE.Mesh(sphereGeo, sphereMat);
        const wireMesh = new THREE.Mesh(sphereGeo, sphereWireMat);
        scene.add(mesh);
        scene.add(wireMesh);

        // Particles
        const partGeo = new THREE.BufferGeometry();
        const MAX_PARTICLES = 1000;
        const partPos = new Float32Array(MAX_PARTICLES * 3);
        partGeo.setAttribute('position', new THREE.BufferAttribute(partPos, 3));
        const partMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
        particlesSystem = new THREE.Points(partGeo, partMat);
        scene.add(particlesSystem);

        // --- LOGIC ---

        function updateScalarField(t) {
            // Phi(x) = exp(-|x-c(t)|^2 / sigma)
            // Moving center c(t)
            const cx = radius * Math.sin(t * 0.5);
            const cy = radius * Math.cos(t * 0.5);
            const cz = 0;

            let minP = Infinity, maxP = -Infinity;

            // 1. Compute Phi and approx Gradient
            const colors = sphereGeo.attributes.color;

            for (let i = 0; i < vertexCount; i++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);
                const z = positionAttribute.getZ(i);

                const d2 = (x - cx) ** 2 + (y - cy) ** 2 + (z - cz) ** 2;
                const phi = 2.0 * Math.exp(-d2 / 5.0);

                // For entropic potential, we approximate V ~ phi for visualization
                // (True calculation requires mesh topology which is complex in vanilla Three.js without Connectivity)
                // We use phi directly as the "entropic potential" proxy for this visual demo
                // since V follows phi's shape.

                const val = phi; // Proxy
                entropicPotential[i] = val;

                if (val < minP) minP = val;
                if (val > maxP) maxP = val;
            }

            // Color map
            for (let i = 0; i < vertexCount; i++) {
                const val = (entropicPotential[i] - minP) / (maxP - minP + 1e-5);
                const c = new THREE.Color().lerpColors(uniforms.colorLow.value, uniforms.colorHigh.value, val);
                colors.setXYZ(i, c.r, c.g, c.b);
            }
            colors.needsUpdate = true;
        }

        function resetParticles() {
            particlePositions = [];
            for (let i = 0; i < 500; i++) {
                // Random point on sphere
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);

                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);

                particlePositions.push(new THREE.Vector3(x, y, z));
            }
            document.getElementById('pCount').innerText = particlePositions.length;
        }

        function evolveParticles(dt) {
            // Simple gradient ascent on the potential (since gravity is attractive to high entropy)
            // F = alpha * grad(S)
            // We approximate grad(S) ~ grad(potential) on the surface

            const alpha = parseFloat(document.getElementById('coupling').value);
            document.getElementById('couplingVal').innerText = alpha;

            const positions = particlesSystem.geometry.attributes.position.array;

            // Center of potential (approx)
            const time = controls.dynamic ? controls.time : 0;
            const cx = radius * Math.sin(time * 0.5);
            const cy = radius * Math.cos(time * 0.5);
            const cz = 0;
            const center = new THREE.Vector3(cx, cy, cz);

            particlePositions.forEach((p, i) => {
                // Gradient of Gaussian points towards center
                // grad( exp(-|x-c|^2) ) ~ -2(x-c) * exp...
                // So "force" is towards c.

                const diff = new THREE.Vector3().subVectors(center, p);
                const distSq = diff.lengthSq();
                diff.normalize();

                // Tangent projection
                const normal = p.clone().normalize();
                const dot = diff.dot(normal);
                diff.sub(normal.multiplyScalar(dot)).normalize();

                // Strength
                const strength = alpha * 0.1 * Math.exp(-distSq / 5.0);

                // Update
                p.add(diff.multiplyScalar(strength));

                // Constrain to sphere
                p.normalize().multiplyScalar(radius);

                // Update buffer
                positions[3 * i] = p.x;
                positions[3 * i + 1] = p.y;
                positions[3 * i + 2] = p.z;
            });

            particlesSystem.geometry.attributes.position.needsUpdate = true;
        }

        // Loop
        function animate() {
            requestAnimationFrame(animate);

            if (document.getElementById('dynamicToggle').checked) {
                controls.time += 0.02;
            } else {
                controls.time = 0;
            }
            document.getElementById('time').innerText = controls.time.toFixed(2);

            updateScalarField(controls.time);
            evolveParticles(0.1);

            // Rotate scene slowly
            scene.rotation.y += 0.001;

            renderer.render(scene, camera);
        }

        // Init
        resetParticles();
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>