/**
 * Legendrian Submanifold Module
 * 
 * Legendrian submanifolds and Hamilton-Jacobi theory.
 * Extracted from index.js for modular organization.
 * 
 * @module contact/legendrian
 * @license MIT
 */

(function (global) {
    'use strict';

    // ============================================================================
    // LEGENDRIAN SUBMANIFOLDS & HAMILTON-JACOBI
    // ============================================================================

    /**
     * LegendrianSubmanifold: n-dimensional submanifold L ⊂ M where α|_L = 0
     * 
     * Generated by a function A(x):
     *   u = A(x)
     *   p_a = ∂_a A(x)
     * 
     * Hamilton-Jacobi constraint: H(x, A(x), ∂A(x)) = 0
     */
    class LegendrianSubmanifold {
        /**
         * @param {ContactManifold} manifold
         * @param {Function} generatingFunc - A(x) → number
         * @param {Function} [dA] - Gradient ∂_a A(x)
         */
        constructor(manifold, generatingFunc, dA = null) {
            this.manifold = manifold;
            this.A = generatingFunc;
            this._dA = dA;
        }

        /**
         * Numerical gradient of generating function
         */
        gradient(x, h = 1e-7) {
            if (this._dA) {
                return this._dA(x);
            }

            const grad = {};
            for (const coord of this.manifold.baseCoords) {
                const xPlus = { ...x, [coord]: x[coord] + h };
                const xMinus = { ...x, [coord]: x[coord] - h };
                grad[coord] = (this.A(xPlus) - this.A(xMinus)) / (2 * h);
            }
            return grad;
        }

        /**
         * Lift base point to contact manifold via Legendrian embedding
         * @param {Object} x - Base coordinates { x^a: value }
         */
        lift(x) {
            const coords = { ...x };

            // u = A(x)
            coords[this.manifold.fiberCoord] = this.A(x);

            // p_a = ∂_a A(x)
            const grad = this.gradient(x);
            for (let i = 0; i < this.manifold.n; i++) {
                const xCoord = this.manifold.baseCoords[i];
                const pCoord = this.manifold.momentaCoords[i];
                coords[pCoord] = grad[xCoord];
            }

            return this.manifold.point(coords);
        }

        /**
         * Verify Legendrian condition: α|_L = 0
         * For any tangent vector to L, α(v) should vanish
         */
        verifyLegendrianCondition(x) {
            // For generating function construction, this is automatic
            // α = du - p_a dx^a = dA - ∂_a A dx^a = 0 on L
            return true;
        }

        /**
         * Hamilton-Jacobi constraint: H(x, A(x), ∂A(x)) = 0
         * @param {ContactHamiltonian} hamiltonian
         */
        hamiltonJacobiResidual(x, hamiltonian) {
            const pt = this.lift(x);
            return hamiltonian.evaluate(pt);
        }

        /**
         * Sample the Legendrian submanifold
         * @param {Function} sampler - () => base coordinates x
         * @param {number} n - Number of samples
         */
        sample(sampler, n) {
            const points = [];
            for (let i = 0; i < n; i++) {
                const x = sampler();
                points.push(this.lift(x));
            }
            return points;
        }
    }

    // ============================================================================
    // EXPORTS
    // ============================================================================

    const Legendrian = {
        LegendrianSubmanifold
    };

    // Export for different module systems
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = Legendrian;
    } else if (typeof define === 'function' && define.amd) {
        define([], () => Legendrian);
    } else {
        global.LegendrianSubmanifold = Legendrian;
    }

})(typeof window !== 'undefined' ? window : global);
